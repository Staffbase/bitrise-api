// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new operations API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for operations API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	ActivityList(params *ActivityListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ActivityListOK, error)

	AddonListByApp(params *AddonListByAppParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddonListByAppOK, error)

	AddonListByOrganization(params *AddonListByOrganizationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddonListByOrganizationOK, error)

	AddonListByUser(params *AddonListByUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddonListByUserOK, error)

	AddonsList(params *AddonsListParams, opts ...ClientOption) (*AddonsListOK, error)

	AddonsShow(params *AddonsShowParams, opts ...ClientOption) (*AddonsShowOK, error)

	AndroidKeystoreFileConfirm(params *AndroidKeystoreFileConfirmParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AndroidKeystoreFileConfirmOK, error)

	AndroidKeystoreFileCreate(params *AndroidKeystoreFileCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AndroidKeystoreFileCreateCreated, error)

	AndroidKeystoreFileDelete(params *AndroidKeystoreFileDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AndroidKeystoreFileDeleteOK, error)

	AndroidKeystoreFileList(params *AndroidKeystoreFileListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AndroidKeystoreFileListOK, error)

	AppConfigCreate(params *AppConfigCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppConfigCreateOK, error)

	AppConfigDatastoreShow(params *AppConfigDatastoreShowParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppConfigDatastoreShowOK, error)

	AppCreate(params *AppCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppCreateOK, error)

	AppDelete(params *AppDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppDeleteOK, error)

	AppFinish(params *AppFinishParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppFinishOK, error)

	AppList(params *AppListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppListOK, error)

	AppListByOrganization(params *AppListByOrganizationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppListByOrganizationOK, error)

	AppListByUser(params *AppListByUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppListByUserOK, error)

	AppNotifications(params *AppNotificationsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppNotificationsOK, error)

	AppRolesQuery(params *AppRolesQueryParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppRolesQueryOK, error)

	AppRolesUpdate(params *AppRolesUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppRolesUpdateOK, error)

	AppSetupBitriseYmlConfigGet(params *AppSetupBitriseYmlConfigGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppSetupBitriseYmlConfigGetOK, error)

	AppSetupBitriseYmlConfigUpdate(params *AppSetupBitriseYmlConfigUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppSetupBitriseYmlConfigUpdateNoContent, error)

	AppShow(params *AppShowParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppShowOK, error)

	AppUpdate(params *AppUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppUpdateOK, error)

	AppWebhookCreate(params *AppWebhookCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppWebhookCreateOK, error)

	AppleAPICredentialList(params *AppleAPICredentialListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppleAPICredentialListOK, error)

	ArchivedBuildsList(params *ArchivedBuildsListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ArchivedBuildsListOK, error)

	ArtifactDelete(params *ArtifactDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ArtifactDeleteOK, error)

	ArtifactList(params *ArtifactListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ArtifactListOK, error)

	ArtifactShow(params *ArtifactShowParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ArtifactShowOK, error)

	ArtifactUpdate(params *ArtifactUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ArtifactUpdateOK, error)

	BranchList(params *BranchListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BranchListOK, error)

	BuildAbort(params *BuildAbortParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildAbortOK, error)

	BuildBitriseYmlShow(params *BuildBitriseYmlShowParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildBitriseYmlShowOK, error)

	BuildCertificateConfirm(params *BuildCertificateConfirmParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildCertificateConfirmOK, error)

	BuildCertificateCreate(params *BuildCertificateCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildCertificateCreateCreated, error)

	BuildCertificateDelete(params *BuildCertificateDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildCertificateDeleteOK, error)

	BuildCertificateList(params *BuildCertificateListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildCertificateListOK, error)

	BuildCertificateShow(params *BuildCertificateShowParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildCertificateShowOK, error)

	BuildCertificateUpdate(params *BuildCertificateUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildCertificateUpdateOK, error)

	BuildList(params *BuildListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildListOK, error)

	BuildListAll(params *BuildListAllParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildListAllOK, error)

	BuildLog(params *BuildLogParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error

	BuildRequestList(params *BuildRequestListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildRequestListOK, error)

	BuildRequestUpdate(params *BuildRequestUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildRequestUpdateOK, error)

	BuildShow(params *BuildShowParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildShowOK, error)

	BuildTrigger(params *BuildTriggerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildTriggerCreated, error)

	BuildWorkflowList(params *BuildWorkflowListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildWorkflowListOK, error)

	CacheItemDelete(params *CacheItemDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CacheItemDeleteOK, error)

	CacheItemDeleteAll(params *CacheItemDeleteAllParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CacheItemDeleteAllOK, error)

	CacheItemDownload(params *CacheItemDownloadParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CacheItemDownloadOK, error)

	CacheList(params *CacheListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CacheListOK, error)

	GenericProjectFileConfirm(params *GenericProjectFileConfirmParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GenericProjectFileConfirmOK, error)

	GenericProjectFileDelete(params *GenericProjectFileDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GenericProjectFileDeleteOK, error)

	GenericProjectFileList(params *GenericProjectFileListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GenericProjectFileListOK, error)

	GenericProjectFileShow(params *GenericProjectFileShowParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GenericProjectFileShowOK, error)

	GenericProjectFileUpdate(params *GenericProjectFileUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GenericProjectFileUpdateOK, error)

	GenericProjectFilesCreate(params *GenericProjectFilesCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GenericProjectFilesCreateCreated, error)

	OrgList(params *OrgListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*OrgListOK, error)

	OrgShow(params *OrgShowParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*OrgShowOK, error)

	OrganizationMachineTypeUpdate(params *OrganizationMachineTypeUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*OrganizationMachineTypeUpdateOK, error)

	OrganzationGroupsList(params *OrganzationGroupsListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*OrganzationGroupsListOK, error)

	OutgoingWebhookCreate(params *OutgoingWebhookCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*OutgoingWebhookCreateOK, error)

	OutgoingWebhookDelete(params *OutgoingWebhookDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*OutgoingWebhookDeleteOK, error)

	OutgoingWebhookList(params *OutgoingWebhookListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*OutgoingWebhookListOK, error)

	OutgoingWebhookUpdate(params *OutgoingWebhookUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*OutgoingWebhookUpdateOK, error)

	PipelineAbort(params *PipelineAbortParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PipelineAbortOK, error)

	PipelineList(params *PipelineListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PipelineListOK, error)

	PipelineListAll(params *PipelineListAllParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PipelineListAllOK, error)

	PipelineRebuild(params *PipelineRebuildParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PipelineRebuildCreated, error)

	PipelineShow(params *PipelineShowParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PipelineShowOK, error)

	ProvisioningProfileConfirm(params *ProvisioningProfileConfirmParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ProvisioningProfileConfirmOK, error)

	ProvisioningProfileCreate(params *ProvisioningProfileCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ProvisioningProfileCreateCreated, error)

	ProvisioningProfileDelete(params *ProvisioningProfileDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ProvisioningProfileDeleteOK, error)

	ProvisioningProfileList(params *ProvisioningProfileListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ProvisioningProfileListOK, error)

	ProvisioningProfileShow(params *ProvisioningProfileShowParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ProvisioningProfileShowOK, error)

	ProvisioningProfileUpdate(params *ProvisioningProfileUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ProvisioningProfileUpdateOK, error)

	ReleaseCreateAppStore(params *ReleaseCreateAppStoreParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReleaseCreateAppStoreCreated, error)

	ReleaseCreateGooglePlay(params *ReleaseCreateGooglePlayParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReleaseCreateGooglePlayCreated, error)

	SecretDelete(params *SecretDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecretDeleteNoContent, error)

	SecretList(params *SecretListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecretListOK, error)

	SecretUpsert(params *SecretUpsertParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecretUpsertCreated, *SecretUpsertNoContent, error)

	SecretValueGet(params *SecretValueGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecretValueGetOK, error)

	SSHKeyCreate(params *SSHKeyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SSHKeyCreateOK, error)

	TestDeviceList(params *TestDeviceListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*TestDeviceListOK, error)

	UserMachineTypeUpdate(params *UserMachineTypeUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UserMachineTypeUpdateOK, error)

	UserPlan(params *UserPlanParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UserPlanOK, error)

	UserProfile(params *UserProfileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UserProfileOK, error)

	UserShow(params *UserShowParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UserShowOK, error)

	WebhookDeliveryItemList(params *WebhookDeliveryItemListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*WebhookDeliveryItemListOK, error)

	WebhookDeliveryItemRedeliver(params *WebhookDeliveryItemRedeliverParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*WebhookDeliveryItemRedeliverOK, error)

	WebhookDeliveryItemShow(params *WebhookDeliveryItemShowParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*WebhookDeliveryItemShowOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
ActivityList gets list of bitrise activity events

List all the Bitrise activity events
*/
func (a *Client) ActivityList(params *ActivityListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ActivityListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewActivityListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "activity-list",
		Method:             "GET",
		PathPattern:        "/me/activities",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ActivityListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ActivityListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for activity-list: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AddonListByApp gets list of the addons for apps

List all the provisioned addons for the authorized apps
*/
func (a *Client) AddonListByApp(params *AddonListByAppParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddonListByAppOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddonListByAppParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "addon-list-by-app",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/addons",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AddonListByAppReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddonListByAppOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for addon-list-by-app: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AddonListByOrganization gets list of the addons for organization

List all the provisioned addons for organization
*/
func (a *Client) AddonListByOrganization(params *AddonListByOrganizationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddonListByOrganizationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddonListByOrganizationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "addon-list-by-organization",
		Method:             "GET",
		PathPattern:        "/organizations/{organization-slug}/addons",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AddonListByOrganizationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddonListByOrganizationOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for addon-list-by-organization: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AddonListByUser gets list of the addons for user

List all the provisioned addons for the authenticated user
*/
func (a *Client) AddonListByUser(params *AddonListByUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddonListByUserOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddonListByUserParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "addon-list-by-user",
		Method:             "GET",
		PathPattern:        "/users/{user-slug}/addons",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AddonListByUserReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddonListByUserOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for addon-list-by-user: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AddonsList gets list of available bitrise addons

List all the available Bitrise addons
*/
func (a *Client) AddonsList(params *AddonsListParams, opts ...ClientOption) (*AddonsListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddonsListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "addons-list",
		Method:             "GET",
		PathPattern:        "/addons",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AddonsListReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddonsListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for addons-list: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AddonsShow gets a specific bitrise addon

Show details of a specific Bitrise addon
*/
func (a *Client) AddonsShow(params *AddonsShowParams, opts ...ClientOption) (*AddonsShowOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddonsShowParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "addons-show",
		Method:             "GET",
		PathPattern:        "/addons/{addon-id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AddonsShowReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddonsShowOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for addons-show: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AndroidKeystoreFileConfirm confirms an android keystore file upload

This is the last step of uploading an android keystore file to Bitrise. Confirm the android keystore file upload and view the file on the Code Signing tab of a specific app. Read more in our [Confirming the upload](https://devcenter.bitrise.io/api/managing-files-in-generic-file-storage/#confirming-the-file-upload) guide.
*/
func (a *Client) AndroidKeystoreFileConfirm(params *AndroidKeystoreFileConfirmParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AndroidKeystoreFileConfirmOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAndroidKeystoreFileConfirmParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "android-keystore-file-confirm",
		Method:             "POST",
		PathPattern:        "/apps/{app-slug}/android-keystore-files/{android-keystore-file-slug}/uploaded",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AndroidKeystoreFileConfirmReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AndroidKeystoreFileConfirmOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for android-keystore-file-confirm: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AndroidKeystoreFileCreate creates an android keystore file

Add a new Android keystore file to an app. `keystore_file_name` is required if there is already an existing keystore file for the app. It will determine the environment variable key to be used to refer to the keystore file in builds. E.g. `BITRISE_ANDROID_KEYSTORE_<keystore_file_name>_URL`. The `keystore_file_name` can only contain letters, numbers, and underscores.
*/
func (a *Client) AndroidKeystoreFileCreate(params *AndroidKeystoreFileCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AndroidKeystoreFileCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAndroidKeystoreFileCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "android-keystore-file-create",
		Method:             "POST",
		PathPattern:        "/apps/{app-slug}/android-keystore-files",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AndroidKeystoreFileCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AndroidKeystoreFileCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for android-keystore-file-create: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AndroidKeystoreFileDelete deletes an android keystore file

Delete an app's android keystore file. You can fetch an app's android keystore file slug if you first list all the uploaded files with the [GET /apps/{app-slug}/android-keystore-files](https://api-docs.bitrise.io/#/android-keystore-file/android-keystore-file-list) endpoint. Read more in our [Deleting a file](https://devcenter.bitrise.io/api/managing-android-keystore-files.html) guide.
*/
func (a *Client) AndroidKeystoreFileDelete(params *AndroidKeystoreFileDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AndroidKeystoreFileDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAndroidKeystoreFileDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "android-keystore-file-delete",
		Method:             "DELETE",
		PathPattern:        "/apps/{app-slug}/android-keystore-files/{android-keystore-file-slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AndroidKeystoreFileDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AndroidKeystoreFileDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for android-keystore-file-delete: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AndroidKeystoreFileList gets a list of the android keystore files

List all the android keystore files that have been uploaded to a specific app.
*/
func (a *Client) AndroidKeystoreFileList(params *AndroidKeystoreFileListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AndroidKeystoreFileListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAndroidKeystoreFileListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "android-keystore-file-list",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/android-keystore-files",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AndroidKeystoreFileListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AndroidKeystoreFileListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for android-keystore-file-list: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AppConfigCreate uploads a new bitrise yml for your application

Upload a new bitrise.yml for your application.
*/
func (a *Client) AppConfigCreate(params *AppConfigCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppConfigCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAppConfigCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "app-config-create",
		Method:             "POST",
		PathPattern:        "/apps/{app-slug}/bitrise.yml",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AppConfigCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AppConfigCreateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for app-config-create: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AppConfigDatastoreShow gets bitrise yml of a specific app

Get the full `bitrise.yml` configuration of an application, by providing the app slug. It returns the current `bitrise.yml` that is stored on bitrise.io in full, including the trigger map, the different workflows and the Steps.
*/
func (a *Client) AppConfigDatastoreShow(params *AppConfigDatastoreShowParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppConfigDatastoreShowOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAppConfigDatastoreShowParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "app-config-datastore-show",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/bitrise.yml",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AppConfigDatastoreShowReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AppConfigDatastoreShowOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for app-config-datastore-show: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AppCreate adds a new app

Add a new app to Bitrise. This is the first step of the app registration process. To successfully set it up, you need to provide the required app parameters: the repository URL and the isPublic field. Read more about the app creation process in our [detailed guide](https://devcenter.bitrise.io/api/adding-and-managing-apps/#adding-a-new-app).
*/
func (a *Client) AppCreate(params *AppCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAppCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "app-create",
		Method:             "POST",
		PathPattern:        "/apps/register",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AppCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AppCreateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for app-create: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AppDelete deletes an app

Deletes an app by slug. Use with care, make sure you really want to delete the app. This action cannot be undone.
*/
func (a *Client) AppDelete(params *AppDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAppDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "app-delete",
		Method:             "DELETE",
		PathPattern:        "/apps/{app-slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AppDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AppDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for app-delete: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AppFinish saves the application at the end of the app registration process

Save the application after registering it on Bitrise and registering an SSH key (and, optionally, adding a webhook). With this endpoint you can define the initial configuration, define application-level environment variables, determine the project type, and set an Organization to be the owner of the app. Read more about the app registration process in our [detailed guide](https://devcenter.bitrise.io/api/adding-and-managing-apps/#adding-a-new-app).
*/
func (a *Client) AppFinish(params *AppFinishParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppFinishOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAppFinishParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "app-finish",
		Method:             "POST",
		PathPattern:        "/apps/{app-slug}/finish",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AppFinishReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AppFinishOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for app-finish: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AppList gets list of the apps

List all the apps available for the authenticated account, including those that are owned by other users or Organizations.
*/
func (a *Client) AppList(params *AppListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAppListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "app-list",
		Method:             "GET",
		PathPattern:        "/apps",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AppListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AppListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for app-list: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AppListByOrganization gets list of the apps for an organization

List all the available apps owned by a given organization. [Find the organization URL](https://devcenter.bitrise.io/team-management/organizations/org-url/) of the organisations you are part of; be aware that the endpoint will not return any apps if the authenticated account is not a member of the given organisation.
*/
func (a *Client) AppListByOrganization(params *AppListByOrganizationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppListByOrganizationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAppListByOrganizationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "app-list-by-organization",
		Method:             "GET",
		PathPattern:        "/organizations/{org-slug}/apps",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AppListByOrganizationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AppListByOrganizationOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for app-list-by-organization: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AppListByUser gets list of the apps for a user

List all the available apps for the given user.  It needs the user slug that you can get from the [GET /me](https://api-docs.bitrise.io/#/user/user-profile) endpoint.
*/
func (a *Client) AppListByUser(params *AppListByUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppListByUserOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAppListByUserParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "app-list-by-user",
		Method:             "GET",
		PathPattern:        "/users/{user-slug}/apps",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AppListByUserReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AppListByUserOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for app-list-by-user: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AppNotifications updates the app s notification settings

Updates the app's email notification settings with parameters
*/
func (a *Client) AppNotifications(params *AppNotificationsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppNotificationsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAppNotificationsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "app-notifications",
		Method:             "PATCH",
		PathPattern:        "/apps/{app-slug}/update-email-notifications",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AppNotificationsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AppNotificationsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for app-notifications: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AppRolesQuery lists group roles for an app
*/
func (a *Client) AppRolesQuery(params *AppRolesQueryParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppRolesQueryOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAppRolesQueryParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "app-roles-query",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/roles/{role-name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AppRolesQueryReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AppRolesQueryOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for app-roles-query: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AppRolesUpdate replaces group roles for an app

Replaces the groups for a given role on an app. Only the given groups will be present for a role on the app after this call.
*/
func (a *Client) AppRolesUpdate(params *AppRolesUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppRolesUpdateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAppRolesUpdateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "app-roles-update",
		Method:             "PUT",
		PathPattern:        "/apps/{app-slug}/roles/{role-name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AppRolesUpdateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AppRolesUpdateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for app-roles-update: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AppSetupBitriseYmlConfigGet gettings the location of the application s bitrise yaml

Getting the location of the application's bitrise.yaml. Requires administrator level privileges to the app.
*/
func (a *Client) AppSetupBitriseYmlConfigGet(params *AppSetupBitriseYmlConfigGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppSetupBitriseYmlConfigGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAppSetupBitriseYmlConfigGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "app-setup-bitrise-yml-config-get",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/bitrise.yml/config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AppSetupBitriseYmlConfigGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AppSetupBitriseYmlConfigGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for app-setup-bitrise-yml-config-get: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AppSetupBitriseYmlConfigUpdate changings the location of the application s bitrise yaml

Changing the location of the application's bitrise.yaml. Requires administrator level privileges to the app.
*/
func (a *Client) AppSetupBitriseYmlConfigUpdate(params *AppSetupBitriseYmlConfigUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppSetupBitriseYmlConfigUpdateNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAppSetupBitriseYmlConfigUpdateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "app-setup-bitrise-yml-config-update",
		Method:             "PUT",
		PathPattern:        "/apps/{app-slug}/bitrise.yml/config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AppSetupBitriseYmlConfigUpdateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AppSetupBitriseYmlConfigUpdateNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for app-setup-bitrise-yml-config-update: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AppShow gets a specific app

Get the details of a specific app by providing the app slug. You can get the app slug by calling the [/apps](https://api-docs.bitrise.io/#/application/app-list) endpoint or by opening the app on bitrise.io and copying the slug from the URL.
*/
func (a *Client) AppShow(params *AppShowParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppShowOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAppShowParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "app-show",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AppShowReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AppShowOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for app-show: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AppUpdate updates an app

Updates an app by slug. Only updates the fields specified in the body.
*/
func (a *Client) AppUpdate(params *AppUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppUpdateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAppUpdateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "app-update",
		Method:             "PATCH",
		PathPattern:        "/apps/{app-slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AppUpdateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AppUpdateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for app-update: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AppWebhookCreate registers an incoming webhook for a specific application

[Register an incoming webhook](https://devcenter.bitrise.io/api/incoming-and-outgoing-webhooks/#incoming-webhooks) for a specific application. You can do this during the app registration process or at any other time in an app's life. When calling this endpoint, a webhook is registered at your git provider: this is necessary to automatically trigger builds on Bitrise.
*/
func (a *Client) AppWebhookCreate(params *AppWebhookCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppWebhookCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAppWebhookCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "app-webhook-create",
		Method:             "POST",
		PathPattern:        "/apps/{app-slug}/register-webhook",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AppWebhookCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AppWebhookCreateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for app-webhook-create: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AppleAPICredentialList lists apple API credentials for a specific user

List Apple API credentials for a specific Bitrise user
*/
func (a *Client) AppleAPICredentialList(params *AppleAPICredentialListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AppleAPICredentialListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAppleAPICredentialListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "apple-api-credential-list",
		Method:             "GET",
		PathPattern:        "/users/{user-slug}/apple-api-credentials",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AppleAPICredentialListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AppleAPICredentialListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for apple-api-credential-list: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ArchivedBuildsList lists 1000 archived builds of an app

List the first 1000 archived builds of a specified Bitrise app. Set parameters to filter builds:
*/
func (a *Client) ArchivedBuildsList(params *ArchivedBuildsListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ArchivedBuildsListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewArchivedBuildsListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "archived-builds-list",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/archived-builds",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ArchivedBuildsListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ArchivedBuildsListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for archived-builds-list: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ArtifactDelete deletes a build artifact

Delete a build artifact of an app's build. The required parameters are app slug, build slug and artifact slug. You can fetch the build artifact slug if you first list all build artifacts of an app with the [/apps/](https://api-docs.bitrise.io/#/build-artifact/artifact-list) endpoint.
*/
func (a *Client) ArtifactDelete(params *ArtifactDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ArtifactDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewArtifactDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "artifact-delete",
		Method:             "DELETE",
		PathPattern:        "/apps/{app-slug}/builds/{build-slug}/artifacts/{artifact-slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ArtifactDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ArtifactDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for artifact-delete: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ArtifactList gets a list of all build artifacts

List all build artifacts that have been generated for an app's build. This endpoint can retrieve artifacts from the archive as well. You can use the created build artifact slugs from the response output to retrieve data of a specific build artifact with the [GET/apps/](https://api-docs.bitrise.io/#/build-artifact/artifact-show) endpoint or update a build artifact with the [PATCH/apps](https://api-docs.bitrise.io/#/build-artifact/artifact-update) endpoint.
*/
func (a *Client) ArtifactList(params *ArtifactListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ArtifactListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewArtifactListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "artifact-list",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/builds/{build-slug}/artifacts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ArtifactListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ArtifactListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for artifact-list: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ArtifactShow gets a specific build artifact

Retrieve data of a specific build artifact. The endpoint can retrieve archived artifacts as well. The response output contains a time-limited download url (expires in 10 minutes) and a public install-page URL. You can view the build artifact with both URLs, but the public install-page url will not work unless you [enable it](https://devcenter.bitrise.io/tutorials/deploy/bitrise-app-deployment/#enabling-public-page-for-the-app).
*/
func (a *Client) ArtifactShow(params *ArtifactShowParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ArtifactShowOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewArtifactShowParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "artifact-show",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/builds/{build-slug}/artifacts/{artifact-slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ArtifactShowReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ArtifactShowOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for artifact-show: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ArtifactUpdate updates a build artifact

Update the `is_public_page_enabled` attribute of your app's build. The required parameters are app slug, build slug and artifact slug. You can fetch the build artifact slug if you first list all build artifacts of an app with the [GET /apps/](https://api-docs.bitrise.io/#/build-artifact/artifact-list) endpoint.
*/
func (a *Client) ArtifactUpdate(params *ArtifactUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ArtifactUpdateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewArtifactUpdateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "artifact-update",
		Method:             "PATCH",
		PathPattern:        "/apps/{app-slug}/builds/{build-slug}/artifacts/{artifact-slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ArtifactUpdateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ArtifactUpdateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for artifact-update: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
BranchList lists the branches with existing builds of an app s repository

Lists only those branches of a specified Bitrise app that have existing builds.
*/
func (a *Client) BranchList(params *BranchListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BranchListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBranchListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "branch-list",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/branches",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &BranchListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BranchListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for branch-list: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
BuildAbort aborts a specific build

Abort a specific build. Set an abort reason with the `abort_reason` parameter. Use the `abort_with_success` parameter to abort a build but still count it as a successful one.
*/
func (a *Client) BuildAbort(params *BuildAbortParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildAbortOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBuildAbortParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "build-abort",
		Method:             "POST",
		PathPattern:        "/apps/{app-slug}/builds/{build-slug}/abort",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &BuildAbortReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BuildAbortOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for build-abort: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
BuildBitriseYmlShow gets the bitrise yml of a build

Get the bitrise.yml file of one of the builds of a given app. This will return the `bitrise.yml` configuration with which the build ran. You can compare it to [the current bitrise.yml configuration](https://api-docs.bitrise.io/#/application/app-config-datastore-show) of the app.
*/
func (a *Client) BuildBitriseYmlShow(params *BuildBitriseYmlShowParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildBitriseYmlShowOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBuildBitriseYmlShowParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "build-bitrise-yml-show",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/builds/{build-slug}/bitrise.yml",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &BuildBitriseYmlShowReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BuildBitriseYmlShowOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for build-bitrise-yml-show: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
BuildCertificateConfirm confirms a build certificate upload

This is the last step of uploading a build certificate to Bitrise. Confirm the build certificate upload and view the file on the Code Signing tab of a specific app. Read more in our [Confirming the iOS code signing file upload](https://devcenter.bitrise.io/api/managing-ios-code-signing-files/#confirming-the-ios-code-signing-file-upload) guide.
*/
func (a *Client) BuildCertificateConfirm(params *BuildCertificateConfirmParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildCertificateConfirmOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBuildCertificateConfirmParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "build-certificate-confirm",
		Method:             "POST",
		PathPattern:        "/apps/{app-slug}/build-certificates/{build-certificate-slug}/uploaded",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &BuildCertificateConfirmReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BuildCertificateConfirmOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for build-certificate-confirm: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
BuildCertificateCreate creates a build certificate

Create a temporary pre-signed upload URL for the build certificate and upload the file to AWS with a simple `curl` request. To complete the uploading process and view your files on the Code Signing tab of your app, continue with the [POST /apps/{app-slug}/build-certificates/{build-certificate-slug}/uploaded](https://api-docs.bitrise.io/#/build-certificate/build-certificate-confirm) endpoint. Read more in our [Creating and uploading an iOS code signing file](https://devcenter.bitrise.io/api/managing-ios-code-signing-files/#creating--uploading-an-ios-code-signing-file) guide.
*/
func (a *Client) BuildCertificateCreate(params *BuildCertificateCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildCertificateCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBuildCertificateCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "build-certificate-create",
		Method:             "POST",
		PathPattern:        "/apps/{app-slug}/build-certificates",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &BuildCertificateCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BuildCertificateCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for build-certificate-create: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
BuildCertificateDelete deletes a build certificate

Delete an app's build certificate. You can fetch the build certificate slug for this endpoint if you first call the [GET /apps/{app-slug}/build-certificates](https://api-docs.bitrise.io/#/build-certificate/build-certificate-list) endpoint to list all available build certificates of an app. Read more in our [Deleting an iOS code signing file](https://devcenter.bitrise.io/api/managing-ios-code-signing-files/#deleting-an-ios-code-signing-file) guide.
*/
func (a *Client) BuildCertificateDelete(params *BuildCertificateDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildCertificateDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBuildCertificateDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "build-certificate-delete",
		Method:             "DELETE",
		PathPattern:        "/apps/{app-slug}/build-certificates/{build-certificate-slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &BuildCertificateDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BuildCertificateDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for build-certificate-delete: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
BuildCertificateList gets a list of the build certificates

List all the build certificates that have been uploaded to a specific app. Read more in our [Listing the uploaded iOS code signing files of an app](https://devcenter.bitrise.io/api/managing-ios-code-signing-files/#listing-the-uploaded-ios-code-signing-files-of-an-app) guide.
*/
func (a *Client) BuildCertificateList(params *BuildCertificateListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildCertificateListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBuildCertificateListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "build-certificate-list",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/build-certificates",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &BuildCertificateListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BuildCertificateListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for build-certificate-list: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
BuildCertificateShow gets a specific build certificate

Retrieve data of a specific build certificate. You can fetch the build certificate slug for this endpoint if you first call the [GET /apps/{app-slug}/build-certificates](https://api-docs.bitrise.io/#/build-certificate/build-certificate-list) endpoint to list all available build certificates of an app. Read more in our [Getting a specific iOS code signing file's data](https://devcenter.bitrise.io/api/managing-ios-code-signing-files/#getting-a-specific-ios-code-signing-files-data) guide.
*/
func (a *Client) BuildCertificateShow(params *BuildCertificateShowParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildCertificateShowOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBuildCertificateShowParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "build-certificate-show",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/build-certificates/{build-certificate-slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &BuildCertificateShowReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BuildCertificateShowOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for build-certificate-show: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
BuildCertificateUpdate updates a build certificate

Update an uploaded build certificate's attributes. You can fetch the build certificate slug for this endpoint if you first call the [GET /apps/{app-slug}/build-certificates](https://api-docs.bitrise.io/#/build-certificate/build-certificate-list) endpoint. Read more in our [Updating an uploaded iOS code signing file](https://devcenter.bitrise.io/api/managing-ios-code-signing-files/#confirming-the-ios-code-signing-file-upload) guide.
*/
func (a *Client) BuildCertificateUpdate(params *BuildCertificateUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildCertificateUpdateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBuildCertificateUpdateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "build-certificate-update",
		Method:             "PATCH",
		PathPattern:        "/apps/{app-slug}/build-certificates/{build-certificate-slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &BuildCertificateUpdateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BuildCertificateUpdateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for build-certificate-update: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
BuildList lists all builds of an app

List all the builds of a specified Bitrise app. Set parameters to filter builds: for example, you can search for builds run with a given workflow or all builds that were triggered by Pull Requests. It returns all the relevant data of the build.
*/
func (a *Client) BuildList(params *BuildListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBuildListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "build-list",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/builds",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &BuildListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BuildListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for build-list: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
BuildListAll lists all builds

List all the Bitrise builds that can be accessed with the authenticated account. Filter builds based on their owner, using the owner slug, or the status of the build.
*/
func (a *Client) BuildListAll(params *BuildListAllParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildListAllOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBuildListAllParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "build-list-all",
		Method:             "GET",
		PathPattern:        "/builds",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &BuildListAllReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BuildListAllOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for build-list-all: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
BuildLog gets the build log of a build

Get the build log of a specified build of a Bitrise app. You can get the build slug either by calling the [/builds](https://api-docs.bitrise.io/#/builds/build-list) endpoint or by clicking on the build on bitrise.io and copying the slug from the URL. Preview of the log is returned in `log_chunks` field in JSON format. You can download the full raw log in txt by using the signed url returned in `expiring_raw_log_url`. Be aware that this url is expiring in 10 minutes!
*/
func (a *Client) BuildLog(params *BuildLogParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBuildLogParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "build-log",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/builds/{build-slug}/log",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &BuildLogReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	_, err := a.transport.Submit(op)
	if err != nil {
		return err
	}
	return nil
}

/*
BuildRequestList lists the open build requests for an app

List the existing open build requests of a specified Bitrise app
*/
func (a *Client) BuildRequestList(params *BuildRequestListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildRequestListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBuildRequestListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "build-request-list",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/build-requests",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &BuildRequestListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BuildRequestListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for build-request-list: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
BuildRequestUpdate updates a build request

Update a specific build request of a specific app
*/
func (a *Client) BuildRequestUpdate(params *BuildRequestUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildRequestUpdateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBuildRequestUpdateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "build-request-update",
		Method:             "PATCH",
		PathPattern:        "/apps/{app-slug}/build-requests/{build-request-slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &BuildRequestUpdateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BuildRequestUpdateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for build-request-update: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
BuildShow gets a build of a given app

Get the specified build of a given Bitrise app. You need to provide both an app slug and a build slug. You can get the build slug either by calling the [/builds](https://api-docs.bitrise.io/#/builds/build-list) endpoint or by clicking on the build on bitrise.io and copying the slug from the URL. The endpoint returns all the relevant data of the build.
*/
func (a *Client) BuildShow(params *BuildShowParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildShowOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBuildShowParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "build-show",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/builds/{build-slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &BuildShowReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BuildShowOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for build-show: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
BuildTrigger triggers a new build pipeline

Trigger a new build/pipeline. Specify an app slug and at least one parameter out of three: a git tag or git commit hash, a branch, or a workflow/pipeline ID. You can also set specific parameters for Pull Request builds/pipelines and define additional environment variables for your build/pipeline. [Check out our detailed guide](https://devcenter.bitrise.io/api/build-trigger/).
*/
func (a *Client) BuildTrigger(params *BuildTriggerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildTriggerCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBuildTriggerParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "build-trigger",
		Method:             "POST",
		PathPattern:        "/apps/{app-slug}/builds",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &BuildTriggerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BuildTriggerCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for build-trigger: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
BuildWorkflowList lists the workflows of an app

List the workflows that were triggered at any time for a given Bitrise app. Note that it might list workflows that are currently not defined in the app's `bitrise.yml` configuration - and conversely, workflows that were never triggered will not be listed even if they are defined in the `bitrise.yml` file.
*/
func (a *Client) BuildWorkflowList(params *BuildWorkflowListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BuildWorkflowListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBuildWorkflowListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "build-workflow-list",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/build-workflows",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &BuildWorkflowListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BuildWorkflowListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for build-workflow-list: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
CacheItemDelete deletes a key value cache item

Deletes a key-value cache item. Deleted cache items are no longer accessible and cannot be restored.
*/
func (a *Client) CacheItemDelete(params *CacheItemDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CacheItemDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCacheItemDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cache-item-delete",
		Method:             "DELETE",
		PathPattern:        "/apps/{app-slug}/cache-items/{cache-item-id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CacheItemDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CacheItemDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for cache-item-delete: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
CacheItemDeleteAll deletes all key value cache items belonging to an app

Deletes all key-value cache items created by the builds of an app. Deleted cache items are no longer accessible and cannot be restored.
*/
func (a *Client) CacheItemDeleteAll(params *CacheItemDeleteAllParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CacheItemDeleteAllOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCacheItemDeleteAllParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cache-item-delete-all",
		Method:             "DELETE",
		PathPattern:        "/apps/{app-slug}/cache-items",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CacheItemDeleteAllReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CacheItemDeleteAllOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for cache-item-delete-all: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
CacheItemDownload gets the download URL of a key value cache item

Gets a download URL of a cache item.
*/
func (a *Client) CacheItemDownload(params *CacheItemDownloadParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CacheItemDownloadOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCacheItemDownloadParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cache-item-download",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/cache-items/{cache-item-id}/download",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CacheItemDownloadReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CacheItemDownloadOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for cache-item-download: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
CacheList lists the key value cache items belonging to an app

List all the available cache items that the builds of the app created via the save-cache step.
*/
func (a *Client) CacheList(params *CacheListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CacheListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCacheListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cache-list",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/cache-items",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CacheListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CacheListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for cache-list: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GenericProjectFileConfirm confirms a generic project file upload

This is the last step of uploading a generic project file to Bitrise. Confirm the generic project file upload and view the file on the Code Signing tab of a specific app. Read more in our [Confirming the upload](https://devcenter.bitrise.io/api/managing-files-in-generic-file-storage/#confirming-the-file-upload) guide.
*/
func (a *Client) GenericProjectFileConfirm(params *GenericProjectFileConfirmParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GenericProjectFileConfirmOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGenericProjectFileConfirmParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "generic-project-file-confirm",
		Method:             "POST",
		PathPattern:        "/apps/{app-slug}/generic-project-files/{generic-project-file-slug}/uploaded",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GenericProjectFileConfirmReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GenericProjectFileConfirmOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for generic-project-file-confirm: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GenericProjectFileDelete deletes a generic project file

Delete an app's generic project file. You can fetch an app's generic project file slug if you first list all the uploaded files with the [GET /apps/{app-slug}/generic-project-files](https://api-docs.bitrise.io/#/generic-project-file/generic-project-file-list) endpoint. Read more in our [Deleting a file](https://devcenter.bitrise.io/api/managing-files-in-generic-file-storage/#deleting-a-file) guide.
*/
func (a *Client) GenericProjectFileDelete(params *GenericProjectFileDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GenericProjectFileDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGenericProjectFileDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "generic-project-file-delete",
		Method:             "DELETE",
		PathPattern:        "/apps/{app-slug}/generic-project-files/{generic-project-file-slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GenericProjectFileDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GenericProjectFileDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for generic-project-file-delete: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GenericProjectFileList gets a list of the generic project files

List all the generic project files that have been uploaded to a specific app. Read more in our [Listing the uploaded files of an app](https://devcenter.bitrise.io/api/managing-files-in-generic-file-storage/#listing-the-uploaded-files-of-an-app) guide.
*/
func (a *Client) GenericProjectFileList(params *GenericProjectFileListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GenericProjectFileListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGenericProjectFileListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "generic-project-file-list",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/generic-project-files",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GenericProjectFileListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GenericProjectFileListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for generic-project-file-list: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GenericProjectFileShow gets a specific generic project file

Retrieve data of a specific generic project file to check its attributes and optionally modify them with the [PATCH /apps/](https://api-docs.bitrise.io/#/generic-project-file/generic-project-file-update) endpoint. Read more in our [Retrieving a specific file's data](https://devcenter.bitrise.io/api/managing-files-in-generic-file-storage/#retrieving-a-specific-files-data) guide.
*/
func (a *Client) GenericProjectFileShow(params *GenericProjectFileShowParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GenericProjectFileShowOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGenericProjectFileShowParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "generic-project-file-show",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/generic-project-files/{generic-project-file-slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GenericProjectFileShowReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GenericProjectFileShowOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for generic-project-file-show: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GenericProjectFileUpdate updates a generic project file

Update a generic project file's attributes. You can fetch an app's generic project file slug if you first list all the uploaded files with the [GET /apps/{app-slug}/generic-project-files](https://api-docs.bitrise.io/#/generic-project-file/generic-project-file-list) endpoint. Read more in our [Updating an uploaded file](https://devcenter.bitrise.io/api/managing-files-in-generic-file-storage/#updating-an-uploaded-file) guide.
*/
func (a *Client) GenericProjectFileUpdate(params *GenericProjectFileUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GenericProjectFileUpdateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGenericProjectFileUpdateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "generic-project-file-update",
		Method:             "PATCH",
		PathPattern:        "/apps/{app-slug}/generic-project-files/{generic-project-file-slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GenericProjectFileUpdateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GenericProjectFileUpdateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for generic-project-file-update: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GenericProjectFilesCreate creates a generic project file

Create a temporary pre-signed upload URL (expires in 10 minutes) for the generic project file and upload it to AWS with a simple `curl` request. To complete the uploading process and view your files on the Code Signing tab of your app, continue with the [POST /apps/{app-slug}/generic-project-files/{generic-project-file-slug}/uploaded](https://api-docs.bitrise.io/#/generic-project-file/generic-project-file-confirm) endpoint. Read more in our [Creating and uploading files to Generic File Storage](https://devcenter.bitrise.io/api/managing-files-in-generic-file-storage/#creating-and-uploading-files-to-generic-file-storage) guide.
*/
func (a *Client) GenericProjectFilesCreate(params *GenericProjectFilesCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GenericProjectFilesCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGenericProjectFilesCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "generic-project-files-create",
		Method:             "POST",
		PathPattern:        "/apps/{app-slug}/generic-project-files",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GenericProjectFilesCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GenericProjectFilesCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for generic-project-files-create: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
OrgList lists the organizations that the user is part of

List all Bitrise organizations that the user is part of
*/
func (a *Client) OrgList(params *OrgListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*OrgListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewOrgListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "org-list",
		Method:             "GET",
		PathPattern:        "/organizations",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &OrgListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*OrgListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for org-list: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
OrgShow gets a specified organization

Get a specified Bitrise organization that the user is part of.
*/
func (a *Client) OrgShow(params *OrgShowParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*OrgShowOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewOrgShowParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "org-show",
		Method:             "GET",
		PathPattern:        "/organizations/{org-slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &OrgShowReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*OrgShowOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for org-show: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
OrganizationMachineTypeUpdate migrates machine types

Migrates all apps' machine types of an organization from one machine type to another
*/
func (a *Client) OrganizationMachineTypeUpdate(params *OrganizationMachineTypeUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*OrganizationMachineTypeUpdateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewOrganizationMachineTypeUpdateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "organization-machine-type-update",
		Method:             "PATCH",
		PathPattern:        "/organizations/{org-slug}/apps/machine_types",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &OrganizationMachineTypeUpdateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*OrganizationMachineTypeUpdateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for organization-machine-type-update: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
OrganzationGroupsList lists organizations groups

Lists the groups of an organization
*/
func (a *Client) OrganzationGroupsList(params *OrganzationGroupsListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*OrganzationGroupsListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewOrganzationGroupsListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "organzation-groups-list",
		Method:             "GET",
		PathPattern:        "/organizations/{org-slug}/groups",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &OrganzationGroupsListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*OrganzationGroupsListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for organzation-groups-list: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
OutgoingWebhookCreate creates an outgoing webhook for an app

Create an outgoing webhook for a specified Bitrise app: this can be used to send build events to a specified URL with custom headers. Currently, only build events can trigger outgoing webhooks.
*/
func (a *Client) OutgoingWebhookCreate(params *OutgoingWebhookCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*OutgoingWebhookCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewOutgoingWebhookCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "outgoing-webhook-create",
		Method:             "POST",
		PathPattern:        "/apps/{app-slug}/outgoing-webhooks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &OutgoingWebhookCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*OutgoingWebhookCreateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for outgoing-webhook-create: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
OutgoingWebhookDelete deletes an outgoing webhook of an app

Delete an existing outgoing webhook for a specified Bitrise app.
*/
func (a *Client) OutgoingWebhookDelete(params *OutgoingWebhookDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*OutgoingWebhookDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewOutgoingWebhookDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "outgoing-webhook-delete",
		Method:             "DELETE",
		PathPattern:        "/apps/{app-slug}/outgoing-webhooks/{app-webhook-slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &OutgoingWebhookDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*OutgoingWebhookDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for outgoing-webhook-delete: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
OutgoingWebhookList lists the outgoing webhooks of an app

List all the outgoing webhooks registered for a specified Bitrise app. This returns all the relevant data of the webhook, including the slug of the webhook and its URL.
*/
func (a *Client) OutgoingWebhookList(params *OutgoingWebhookListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*OutgoingWebhookListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewOutgoingWebhookListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "outgoing-webhook-list",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/outgoing-webhooks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &OutgoingWebhookListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*OutgoingWebhookListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for outgoing-webhook-list: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
OutgoingWebhookUpdate updates an outgoing webhook of an app

Update an existing outgoing webhook (URL, events, secrets and headers) for a specified Bitrise app. Even if you do not want to change one of the parameters, you still have to provide that parameter as well: simply use its existing value.
*/
func (a *Client) OutgoingWebhookUpdate(params *OutgoingWebhookUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*OutgoingWebhookUpdateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewOutgoingWebhookUpdateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "outgoing-webhook-update",
		Method:             "PUT",
		PathPattern:        "/apps/{app-slug}/outgoing-webhooks/{app-webhook-slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &OutgoingWebhookUpdateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*OutgoingWebhookUpdateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for outgoing-webhook-update: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
PipelineAbort aborts a pipeline

Aborts a pipeline. You need to provide the app slug and the id of the pipeline. You can add an abort reason, choose to skip notifications and make the abort with success state.
*/
func (a *Client) PipelineAbort(params *PipelineAbortParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PipelineAbortOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPipelineAbortParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "pipeline-abort",
		Method:             "POST",
		PathPattern:        "/apps/{app-slug}/pipelines/{pipeline-id}/abort",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PipelineAbortReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PipelineAbortOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for pipeline-abort: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
PipelineList lists all pipelines and standalone builds of an app

List all the pipelines and standalone builds of a specified Bitrise app. Set parameters to filter pipelines: for example, you can search for pipelines/standalone builds run with a given workflow name or all pipelines/standalone builds that were triggered by Pull Requests. It returns all the relevant data of the pipelines/standalone builds.
*/
func (a *Client) PipelineList(params *PipelineListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PipelineListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPipelineListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "pipeline-list",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/pipelines",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PipelineListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PipelineListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for pipeline-list: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
PipelineListAll lists all pipelines standalone builds

List all the Bitrise pipelines/standalone builds that can be accessed with the authenticated account. Filter pipelines/standalone builds based on their owner, using the owner slug, or the status of the pipeline/standalone build.
*/
func (a *Client) PipelineListAll(params *PipelineListAllParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PipelineListAllOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPipelineListAllParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "pipeline-list-all",
		Method:             "GET",
		PathPattern:        "/pipelines",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PipelineListAllReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PipelineListAllOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for pipeline-list-all: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
PipelineRebuild rebuilds a pipeline

Rebuilds a pipeline. You can rebuild the whole pipeline or only the unsuccessful and subsequent workflows by setting the partial flag to true.
*/
func (a *Client) PipelineRebuild(params *PipelineRebuildParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PipelineRebuildCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPipelineRebuildParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "pipeline-rebuild",
		Method:             "POST",
		PathPattern:        "/apps/{app-slug}/pipelines/{pipeline-id}/rebuild",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PipelineRebuildReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PipelineRebuildCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for pipeline-rebuild: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
PipelineShow gets a pipeline of a given app

Get the specified pipeline of a given Bitrise app. You need to provide both an app slug and a pipeline id. You can get the pipeline id either by calling the [/pipelines](https://api-docs.bitrise.io/#/pipelines/pipeline-list) endpoint or by clicking on the pipeline on bitrise.io and copying the id from the URL. The endpoint returns all the relevant data of the pipeline.
*/
func (a *Client) PipelineShow(params *PipelineShowParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PipelineShowOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPipelineShowParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "pipeline-show",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/pipelines/{pipeline-id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PipelineShowReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PipelineShowOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for pipeline-show: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ProvisioningProfileConfirm confirms a provisioning profile upload

This is the last step of the upload process. Confirm the provisioning profile upload and view the file on the Code Signing tab of a specific app. Read more in our [Confirming the iOS code signing file upload](https://devcenter.bitrise.io/api/managing-ios-code-signing-files/#confirming-the-ios-code-signing-file-upload) guide.
*/
func (a *Client) ProvisioningProfileConfirm(params *ProvisioningProfileConfirmParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ProvisioningProfileConfirmOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewProvisioningProfileConfirmParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "provisioning-profile-confirm",
		Method:             "POST",
		PathPattern:        "/apps/{app-slug}/provisioning-profiles/{provisioning-profile-slug}/uploaded",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ProvisioningProfileConfirmReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ProvisioningProfileConfirmOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for provisioning-profile-confirm: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ProvisioningProfileCreate creates a provisioning profile

Create a temporary pre-signed upload URL (expires in 10 minutes) for the provisioning profile and upload it to AWS with a simple `curl` request. To complete the upload process, continue with the [POST /apps/{app-slug}/provisioning-profiles/{provisioning-profile-slug}/uploaded](https://api-docs.bitrise.io/#/provisioning-profile/provisioning-profile-confirm) endpoint. Read more in our [Creating and uploading an iOS code signing file](https://devcenter.bitrise.io/api/managing-ios-code-signing-files/#creating--uploading-an-ios-code-signing-file) guide.
*/
func (a *Client) ProvisioningProfileCreate(params *ProvisioningProfileCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ProvisioningProfileCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewProvisioningProfileCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "provisioning-profile-create",
		Method:             "POST",
		PathPattern:        "/apps/{app-slug}/provisioning-profiles",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ProvisioningProfileCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ProvisioningProfileCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for provisioning-profile-create: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ProvisioningProfileDelete deletes a provisioning profile

Delete an app's provisioning profile. You can fetch the provisioning profile's slug if you call the [GET /apps/{app-slug}/provisioning-profiles](https://api-docs.bitrise.io/#/provisioning-profile/provisioning-profile-list) endpoint. Read more in our [Deleting an iOS code signing file](https://devcenter.bitrise.io/api/managing-ios-code-signing-files/#deleting-an-ios-code-signing-file) guide.
*/
func (a *Client) ProvisioningProfileDelete(params *ProvisioningProfileDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ProvisioningProfileDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewProvisioningProfileDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "provisioning-profile-delete",
		Method:             "DELETE",
		PathPattern:        "/apps/{app-slug}/provisioning-profiles/{provisioning-profile-slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ProvisioningProfileDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ProvisioningProfileDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for provisioning-profile-delete: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ProvisioningProfileList gets a list of the provisioning profiles

List all the provisioning profiles that have been uploaded to a specific app. Read more in our [Listing the uploaded iOS code signing files of an app](https://devcenter.bitrise.io/api/managing-ios-code-signing-files/#listing-the-uploaded-ios-code-signing-files-of-an-app) guide.
*/
func (a *Client) ProvisioningProfileList(params *ProvisioningProfileListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ProvisioningProfileListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewProvisioningProfileListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "provisioning-profile-list",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/provisioning-profiles",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ProvisioningProfileListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ProvisioningProfileListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for provisioning-profile-list: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ProvisioningProfileShow gets a specific provisioning profile

Retrieve data of a specific provisioning profile. You can fetch the provisioning profile's slug if you call the [GET /apps/{app-slug}/provisioning-profiles](https://api-docs.bitrise.io/#/provisioning-profile/provisioning-profile-list) endpoint. Read more in our [Getting a specific iOS code signing file's data](https://devcenter.bitrise.io/api/managing-ios-code-signing-files/#getting-a-specific-ios-code-signing-files-data) guide.
*/
func (a *Client) ProvisioningProfileShow(params *ProvisioningProfileShowParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ProvisioningProfileShowOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewProvisioningProfileShowParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "provisioning-profile-show",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/provisioning-profiles/{provisioning-profile-slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ProvisioningProfileShowReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ProvisioningProfileShowOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for provisioning-profile-show: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ProvisioningProfileUpdate updates a provisioning profile

Update an uploaded provisioning profile's attributes. You can fetch the provisioning profile's slug if you call the [GET /apps/{app-slug}/provisioning-profiles](https://api-docs.bitrise.io/#/provisioning-profile/provisioning-profile-list) endpoint. Read more in our [Updating an uploaded iOS code signing file](https://devcenter.bitrise.io/api/managing-ios-code-signing-files/#confirming-the-ios-code-signing-file-upload) guide.
*/
func (a *Client) ProvisioningProfileUpdate(params *ProvisioningProfileUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ProvisioningProfileUpdateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewProvisioningProfileUpdateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "provisioning-profile-update",
		Method:             "PATCH",
		PathPattern:        "/apps/{app-slug}/provisioning-profiles/{provisioning-profile-slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ProvisioningProfileUpdateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ProvisioningProfileUpdateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for provisioning-profile-update: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ReleaseCreateAppStore creates a new apple app store release for the app

Create a new iOS release for the specified app. If the release candidate parameters (`release_branch` and `workflow`) are specified then the latest successful build is automatically picked up as release candidate and if `automatic_testflight_upload` is also turned on, then an upload to TestFlight is started immediately. You can use this endpoint to set up a fully automated release flow.
*/
func (a *Client) ReleaseCreateAppStore(params *ReleaseCreateAppStoreParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReleaseCreateAppStoreCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReleaseCreateAppStoreParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "release-create-app-store",
		Method:             "POST",
		PathPattern:        "/apps/{app-slug}/releases/app-store",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ReleaseCreateAppStoreReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReleaseCreateAppStoreCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for release-create-app-store: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ReleaseCreateGooglePlay creates a new google play store release for the app

Create a new android release for the specified app. If the release candidate parameters (`release_branch` and `workflow`) are specified then the latest successful build is automatically picked up as release candidate and if `automatic_play_console_upload` is also turned on, then an upload to Google Play Console is started immediately. You can use this endpoint to set up a fully automated release flow.
*/
func (a *Client) ReleaseCreateGooglePlay(params *ReleaseCreateGooglePlayParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReleaseCreateGooglePlayCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReleaseCreateGooglePlayParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "release-create-google-play",
		Method:             "POST",
		PathPattern:        "/apps/{app-slug}/releases/google-play",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ReleaseCreateGooglePlayReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReleaseCreateGooglePlayCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for release-create-google-play: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
SecretDelete deletes an application secret

Delete an application secret. Requires administrator level privileges to the app.
*/
func (a *Client) SecretDelete(params *SecretDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecretDeleteNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecretDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "secret-delete",
		Method:             "DELETE",
		PathPattern:        "/apps/{app-slug}/secrets/{secret-name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecretDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecretDeleteNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for secret-delete: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
SecretList lists the application secrets with no values

List the application secrets (with no values). Requires administrator level privileges to the app.
*/
func (a *Client) SecretList(params *SecretListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecretListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecretListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "secret-list",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/secrets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecretListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecretListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for secret-list: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
SecretUpsert upserts an application secret

Upsert an application secret. Requires administrator level privileges to the app.
*/
func (a *Client) SecretUpsert(params *SecretUpsertParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecretUpsertCreated, *SecretUpsertNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecretUpsertParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "secret-upsert",
		Method:             "PUT",
		PathPattern:        "/apps/{app-slug}/secrets/{secret-name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecretUpsertReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *SecretUpsertCreated:
		return value, nil, nil
	case *SecretUpsertNoContent:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for operations: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
SecretValueGet gets the value of an unprotected application secrets

Get the value of an (unprotected) application secrets. Requires administrator level privileges to the app.
*/
func (a *Client) SecretValueGet(params *SecretValueGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecretValueGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecretValueGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "secret-value-get",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/secrets/{secret-name}/value",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecretValueGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecretValueGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for secret-value-get: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
SSHKeyCreate adds an SSH key to a specific app

Add an SSH-key to a specific app. After creating an app, you need to register the SSH key so that Bitrise will be able to access and clone your repository during the build process. This requires the app slug of your newly created app.
*/
func (a *Client) SSHKeyCreate(params *SSHKeyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SSHKeyCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSSHKeyCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ssh-key-create",
		Method:             "POST",
		PathPattern:        "/apps/{app-slug}/register-ssh-key",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SSHKeyCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SSHKeyCreateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ssh-key-create: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
TestDeviceList lists the test devices for an app

List registered test devices of all members of a specified Bitrise app
*/
func (a *Client) TestDeviceList(params *TestDeviceListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*TestDeviceListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTestDeviceListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "test-device-list",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/test-devices",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TestDeviceListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*TestDeviceListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for test-device-list: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UserMachineTypeUpdate migrates machine types

Migrates all apps' machine types of a user from one machine type to another
*/
func (a *Client) UserMachineTypeUpdate(params *UserMachineTypeUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UserMachineTypeUpdateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUserMachineTypeUpdateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "user-machine-type-update",
		Method:             "PATCH",
		PathPattern:        "/user/{user-slug}/apps/machine_types",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UserMachineTypeUpdateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UserMachineTypeUpdateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for user-machine-type-update: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UserPlan thes subscription plan of the user

Get the subscription of the user: the current plan, any pending plans, and the duration of a trial period if applicable
*/
func (a *Client) UserPlan(params *UserPlanParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UserPlanOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUserPlanParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "user-plan",
		Method:             "GET",
		PathPattern:        "/me/plan",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UserPlanReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UserPlanOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for user-plan: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UserProfile gets your profile info

Shows the authenticated users profile info
*/
func (a *Client) UserProfile(params *UserProfileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UserProfileOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUserProfileParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "user-profile",
		Method:             "GET",
		PathPattern:        "/me",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UserProfileReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UserProfileOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for user-profile: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UserShow gets a specific user

Show information about a specific user
*/
func (a *Client) UserShow(params *UserShowParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UserShowOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUserShowParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "user-show",
		Method:             "GET",
		PathPattern:        "/users/{user-slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UserShowReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UserShowOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for user-show: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
WebhookDeliveryItemList lists the webhook delivery items of an app

List all the delivery items of an outgoing webhook of a Bitrise application
*/
func (a *Client) WebhookDeliveryItemList(params *WebhookDeliveryItemListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*WebhookDeliveryItemListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewWebhookDeliveryItemListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "webhook-delivery-item-list",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/outgoing-webhooks/{app-webhook-slug}/delivery-items",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &WebhookDeliveryItemListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*WebhookDeliveryItemListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for webhook-delivery-item-list: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
WebhookDeliveryItemRedeliver res deliver the webhook delivery items of an app

Re-deliver the delivery item of a specified webhook of a Bitrise application
*/
func (a *Client) WebhookDeliveryItemRedeliver(params *WebhookDeliveryItemRedeliverParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*WebhookDeliveryItemRedeliverOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewWebhookDeliveryItemRedeliverParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "webhook-delivery-item-redeliver",
		Method:             "POST",
		PathPattern:        "/apps/{app-slug}/outgoing-webhooks/{app-webhook-slug}/delivery-items/{webhook-delivery-item-slug}/redeliver",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &WebhookDeliveryItemRedeliverReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*WebhookDeliveryItemRedeliverOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for webhook-delivery-item-redeliver: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
WebhookDeliveryItemShow gets a specific delivery item of a webhook

Get the specified delivery item of an outgoing webhook of a Bitrise application
*/
func (a *Client) WebhookDeliveryItemShow(params *WebhookDeliveryItemShowParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*WebhookDeliveryItemShowOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewWebhookDeliveryItemShowParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "webhook-delivery-item-show",
		Method:             "GET",
		PathPattern:        "/apps/{app-slug}/outgoing-webhooks/{app-webhook-slug}/delivery-items/{webhook-delivery-item-slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &WebhookDeliveryItemShowReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*WebhookDeliveryItemShowOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for webhook-delivery-item-show: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
