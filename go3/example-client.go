// Package examplepkg provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.2 DO NOT EDIT.
package examplepkg

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

const (
	AddonAuthTokenScopes      = "AddonAuthToken.Scopes"
	PersonalAccessTokenScopes = "PersonalAccessToken.Scopes"
)

// Defines values for V0PipelineShowResponseModelStatus.
const (
	Aborted            V0PipelineShowResponseModelStatus = "aborted"
	Failed             V0PipelineShowResponseModelStatus = "failed"
	Initializing       V0PipelineShowResponseModelStatus = "initializing"
	OnHold             V0PipelineShowResponseModelStatus = "on_hold"
	Running            V0PipelineShowResponseModelStatus = "running"
	Succeeded          V0PipelineShowResponseModelStatus = "succeeded"
	SucceededWithAbort V0PipelineShowResponseModelStatus = "succeeded_with_abort"
)

// Defines values for WebsiteBitriseYMLLocation.
const (
	LocationBitriseIo  WebsiteBitriseYMLLocation = "bitrise.io"
	LocationRepository WebsiteBitriseYMLLocation = "repository"
)

// Defines values for AppListParamsSortBy.
const (
	AppListParamsSortByCreatedAt   AppListParamsSortBy = "created_at"
	AppListParamsSortByLastBuildAt AppListParamsSortBy = "last_build_at"
)

// Defines values for BuildListParamsSortBy.
const (
	BuildListParamsSortByCreatedAt    BuildListParamsSortBy = "created_at"
	BuildListParamsSortByRunningFirst BuildListParamsSortBy = "running_first"
)

// Defines values for AppRolesQueryParamsRoleName.
const (
	AppRolesQueryParamsRoleNameAdmin   AppRolesQueryParamsRoleName = "admin"
	AppRolesQueryParamsRoleNameManager AppRolesQueryParamsRoleName = "manager"
	AppRolesQueryParamsRoleNameMember  AppRolesQueryParamsRoleName = "member"
)

// Defines values for AppRolesUpdateParamsRoleName.
const (
	AppRolesUpdateParamsRoleNameAdmin   AppRolesUpdateParamsRoleName = "admin"
	AppRolesUpdateParamsRoleNameManager AppRolesUpdateParamsRoleName = "manager"
	AppRolesUpdateParamsRoleNameMember  AppRolesUpdateParamsRoleName = "member"
)

// Defines values for AppListByOrganizationParamsSortBy.
const (
	AppListByOrganizationParamsSortByCreatedAt   AppListByOrganizationParamsSortBy = "created_at"
	AppListByOrganizationParamsSortByLastBuildAt AppListByOrganizationParamsSortBy = "last_build_at"
)

// Defines values for AppListByUserParamsSortBy.
const (
	AppListByUserParamsSortByCreatedAt   AppListByUserParamsSortBy = "created_at"
	AppListByUserParamsSortByLastBuildAt AppListByUserParamsSortBy = "last_build_at"
)

// AddonsAddon defines model for addons.Addon.
type AddonsAddon struct {
	BannerImage      *string                `json:"banner_image,omitempty"`
	CardHeaderColors *[]string              `json:"card_header_colors,omitempty"`
	Categories       *[]string              `json:"categories,omitempty"`
	Description      *string                `json:"description,omitempty"`
	DeveloperLinks   *[]AddonsDeveloperLink `json:"developer_links,omitempty"`
	DocumentationUrl *string                `json:"documentation_url,omitempty"`
	HasUi            *bool                  `json:"has_ui,omitempty"`
	Icon             *string                `json:"icon,omitempty"`
	Id               *string                `json:"id,omitempty"`
	IsBeta           *bool                  `json:"is_beta,omitempty"`
	Plans            *[]AddonsPlan          `json:"plans,omitempty"`
	Platforms        *[]string              `json:"platforms,omitempty"`
	PreviewImages    *[]string              `json:"preview_images,omitempty"`
	SetupGuide       *AddonsSetupGuide      `json:"setup_guide,omitempty"`
	Subtitle         *string                `json:"subtitle,omitempty"`
	Summary          *string                `json:"summary,omitempty"`
	Title            *string                `json:"title,omitempty"`
}

// AddonsDeveloperLink defines model for addons.DeveloperLink.
type AddonsDeveloperLink struct {
	Title *string `json:"title,omitempty"`
	Url   *string `json:"url,omitempty"`
}

// AddonsFeature defines model for addons.Feature.
type AddonsFeature struct {
	Available   *bool   `json:"available,omitempty"`
	Description *string `json:"description,omitempty"`
	Quantity    *string `json:"quantity,omitempty"`
}

// AddonsPlan defines model for addons.Plan.
type AddonsPlan struct {
	Features *[]AddonsFeature `json:"features,omitempty"`
	Id       *string          `json:"id,omitempty"`
	Name     *string          `json:"name,omitempty"`
	Price    *int             `json:"price,omitempty"`
}

// AddonsSetupGuide defines model for addons.SetupGuide.
type AddonsSetupGuide struct {
	Instructions *[]AddonsSetupInstruction `json:"instructions,omitempty"`
	Notification *string                   `json:"notification,omitempty"`
}

// AddonsSetupInstruction defines model for addons.SetupInstruction.
type AddonsSetupInstruction struct {
	CardContent *string `json:"card_content,omitempty"`
	Description *string `json:"description,omitempty"`
	Type        *string `json:"type,omitempty"`
}

// AppRolesQuery200Response defines model for app_roles_query_200_response.
type AppRolesQuery200Response struct {
	Groups *[]string `json:"groups,omitempty"`
}

// NullsInt64 defines model for nulls.Int64.
type NullsInt64 struct {
	Int64 *int `json:"int64,omitempty"`

	// Valid Valid is true if Int64 is not NULL
	Valid *bool `json:"valid,omitempty"`
}

// NullsString defines model for nulls.String.
type NullsString struct {
	String *string `json:"string,omitempty"`

	// Valid Valid is true if String is not NULL
	Valid *bool `json:"valid,omitempty"`
}

// OrganzationGroupsList200ResponseInner defines model for organzation_groups_list_200_response_inner.
type OrganzationGroupsList200ResponseInner struct {
	Name *string `json:"name,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

// PipelineabledomainArtifactMeta defines model for pipelineabledomain.ArtifactMeta.
type PipelineabledomainArtifactMeta struct {
	ArtifactType *string `json:"artifact_type,omitempty"`
	Id           *string `json:"id,omitempty"`
	Title        *string `json:"title,omitempty"`
	VersionCode  *string `json:"version_code,omitempty"`
	VersionName  *string `json:"version_name,omitempty"`
}

// PipelineabledomainBuildToolInvocation defines model for pipelineabledomain.BuildToolInvocation.
type PipelineabledomainBuildToolInvocation struct {
	InvocationId *string `json:"invocation_id,omitempty"`
	Tool         *string `json:"tool,omitempty"`
	ToolVersion  *string `json:"tool_version,omitempty"`
}

// PipelineabledomainEnvironments defines model for pipelineabledomain.Environments.
type PipelineabledomainEnvironments struct {
	IsExpand *map[string]interface{} `json:"is_expand,omitempty"`
	Key      *string                 `json:"key,omitempty"`
	Value    *map[string]interface{} `json:"value,omitempty"`
}

// PipelineabledomainLocalConfig defines model for pipelineabledomain.LocalConfig.
type PipelineabledomainLocalConfig struct {
	Host     *string `json:"host,omitempty"`
	Username *string `json:"username,omitempty"`
}

// PipelineabledomainTriggerParams defines model for pipelineabledomain.TriggerParams.
type PipelineabledomainTriggerParams struct {
	Branch                           *string                           `json:"branch,omitempty"`
	BranchDest                       *string                           `json:"branch_dest,omitempty"`
	BranchDestRepoOwner              *string                           `json:"branch_dest_repo_owner,omitempty"`
	BranchRepoOwner                  *string                           `json:"branch_repo_owner,omitempty"`
	CommitHash                       *string                           `json:"commit_hash,omitempty"`
	CommitMessage                    *string                           `json:"commit_message,omitempty"`
	Environments                     *[]PipelineabledomainEnvironments `json:"environments,omitempty"`
	PullRequestAuthor                *string                           `json:"pull_request_author,omitempty"`
	PullRequestHeadBranch            *string                           `json:"pull_request_head_branch,omitempty"`
	PullRequestId                    *map[string]interface{}           `json:"pull_request_id,omitempty"`
	PullRequestMergeBranch           *string                           `json:"pull_request_merge_branch,omitempty"`
	PullRequestRepositoryUrl         *string                           `json:"pull_request_repository_url,omitempty"`
	PullRequestUnverifiedMergeBranch *string                           `json:"pull_request_unverified_merge_branch,omitempty"`
	Tag                              *map[string]interface{}           `json:"tag,omitempty"`
}

// ServiceProxyErrorRespModel defines model for service.ProxyErrorRespModel.
type ServiceProxyErrorRespModel struct {
	ErrorMsg *string `json:"error_msg,omitempty"`
}

// ServiceStandardErrorRespModel defines model for service.StandardErrorRespModel.
type ServiceStandardErrorRespModel struct {
	Message *string `json:"message,omitempty"`
}

// V0ActivityEventListResponseModel defines model for v0.ActivityEventListResponseModel.
type V0ActivityEventListResponseModel struct {
	Data   *[]V0ActivityEventResponseItemModel `json:"data,omitempty"`
	Paging *V0PagingResponseModel              `json:"paging,omitempty"`
}

// V0ActivityEventResponseItemModel defines model for v0.ActivityEventResponseItemModel.
type V0ActivityEventResponseItemModel struct {
	CreatedAt               *string      `json:"created_at,omitempty"`
	Description             *NullsString `json:"description,omitempty"`
	EventIcon               *NullsString `json:"event_icon,omitempty"`
	EventStype              *NullsString `json:"event_stype,omitempty"`
	RepositoryAvatarIconUrl *string      `json:"repository_avatar_icon_url,omitempty"`
	RepositoryTitle         *string      `json:"repository_title,omitempty"`
	Slug                    *string      `json:"slug,omitempty"`
	TargetPathString        *NullsString `json:"target_path_string,omitempty"`
	Title                   *NullsString `json:"title,omitempty"`
}

// V0AddOnAppResponseItemModel defines model for v0.AddOnAppResponseItemModel.
type V0AddOnAppResponseItemModel struct {
	Icon          *NullsString `json:"icon,omitempty"`
	Plan          *AddonsPlan  `json:"plan,omitempty"`
	PlanStartedAt *string      `json:"plan_started_at,omitempty"`
	Slug          *string      `json:"slug,omitempty"`
	Title         *string      `json:"title,omitempty"`
}

// V0AddonsListResponseModel defines model for v0.AddonsListResponseModel.
type V0AddonsListResponseModel struct {
	Data *[]AddonsAddon `json:"data,omitempty"`
}

// V0AddonsShowResponseModel defines model for v0.AddonsShowResponseModel.
type V0AddonsShowResponseModel struct {
	Data *AddonsAddon `json:"data,omitempty"`
}

// V0AndroidKeystoreFileUploadParams defines model for v0.AndroidKeystoreFileUploadParams.
type V0AndroidKeystoreFileUploadParams struct {
	Alias              string  `json:"alias"`
	KeystoreFileName   *string `json:"keystore_file_name,omitempty"`
	Password           string  `json:"password"`
	PrivateKeyPassword string  `json:"private_key_password"`
	UploadFileName     string  `json:"upload_file_name"`
	UploadFileSize     int     `json:"upload_file_size"`
}

// V0AppAddOnResponseItemModel defines model for v0.AppAddOnResponseItemModel.
type V0AppAddOnResponseItemModel struct {
	Description      *string           `json:"description,omitempty"`
	DocumentationUrl *string           `json:"documentation_url,omitempty"`
	HasUi            *bool             `json:"has_ui,omitempty"`
	Icon             *string           `json:"icon,omitempty"`
	Id               *string           `json:"id,omitempty"`
	IsBeta           *bool             `json:"is_beta,omitempty"`
	IsEnabled        *bool             `json:"is_enabled,omitempty"`
	LoginUrl         *string           `json:"login_url,omitempty"`
	Plan             *AddonsPlan       `json:"plan,omitempty"`
	Scopes           *[]string         `json:"scopes,omitempty"`
	SetupGuide       *AddonsSetupGuide `json:"setup_guide,omitempty"`
	Summary          *string           `json:"summary,omitempty"`
	TermsUrl         *string           `json:"terms_url,omitempty"`
	Title            *string           `json:"title,omitempty"`
}

// V0AppAddOnsListResponseModel defines model for v0.AppAddOnsListResponseModel.
type V0AppAddOnsListResponseModel struct {
	Data *[]V0AppAddOnResponseItemModel `json:"data,omitempty"`
}

// V0AppConfigRequestParam defines model for v0.AppConfigRequestParam.
type V0AppConfigRequestParam struct {
	// AppConfigDatastoreYaml The bitrise.yml of your application, defined in JSON format
	AppConfigDatastoreYaml string `json:"app_config_datastore_yaml"`
}

// V0AppConfigRespModel defines model for v0.AppConfigRespModel.
type V0AppConfigRespModel map[string]string

// V0AppDeleteRespModel defines model for v0.AppDeleteRespModel.
type V0AppDeleteRespModel struct {
	Msg *string `json:"msg,omitempty"`
}

// V0AppFinishParams defines model for v0.AppFinishParams.
type V0AppFinishParams struct {
	// Config Which config to use. Specify a config that matches your project type (e. g. `default-android-config` for `android`, etc.). If not speficied, default value is `other-config`. The available values are `default-android-config`, `default-cordova-config`, `default-fastlane-android-config`, `default-fastlane-ios-config`, `flutter-config-notest-app-android`, `flutter-config-notest-app-both`, `flutter-config-notest-app-ios`, `flutter-config-test-app-android`, `flutter-config-test-app-both`, `flutter-config-test-app-ios`, `default-ionic-config`, `default-ios-config`, `default-macos-config`, `default-react-native-config`, `default-react-native-expo-config`, `other-config`.
	Config *string `json:"config,omitempty"`

	// Envs Environment variables for the application workflows, e.g. {"env1":"val1","env2":"val2"}
	Envs *map[string]string `json:"envs,omitempty"`

	// Mode config specification mode, has to be specified with `manual` value
	Mode *string `json:"mode,omitempty"`

	// OrganizationSlug The slug of the organization, who will be the owner of the application, if it's not specified, then the authenticated user will be the owner
	OrganizationSlug *string `json:"organization_slug,omitempty"`

	// ProjectType The type of your project (`android`, `ios`, `cordova`, `other`, `xamarin`, `macos`, `ionic`, `react-native`, `fastlane`, null)
	ProjectType string `json:"project_type"`

	// StackId The id of the stack the application will be built (these can be found in the [system report](https://github.com/bitrise-io/bitrise.io/tree/master/system_reports) file names)
	StackId string `json:"stack_id"`
}

// V0AppFinishRespModel defines model for v0.AppFinishRespModel.
type V0AppFinishRespModel struct {
	BranchName                *string `json:"branch_name,omitempty"`
	BuildTriggerToken         *string `json:"build_trigger_token,omitempty"`
	IsWebhookAutoRegSupported *bool   `json:"is_webhook_auto_reg_supported,omitempty"`
	Status                    *string `json:"status,omitempty"`
}

// V0AppListResponseModel defines model for v0.AppListResponseModel.
type V0AppListResponseModel struct {
	Data *[]V0AppResponseItemModel `json:"data,omitempty"`

	// Paging pagination
	Paging *V0PagingResponseModel `json:"paging,omitempty"`
}

// V0AppNotificationSettingsParams defines model for v0.AppNotificationSettingsParams.
type V0AppNotificationSettingsParams struct {
	// OnFailure When should Bitrise send notifications for the users on build failure? Possible values: always, never, change
	OnFailure *string `json:"on_failure,omitempty"`

	// OnSuccess When should Bitrise send notifications for the users on build success? Possible values: always, never, change
	OnSuccess *string `json:"on_success,omitempty"`
}

// V0AppNotificationSettingsUpdateResponse defines model for v0.AppNotificationSettingsUpdateResponse.
type V0AppNotificationSettingsUpdateResponse struct {
	Msg *string `json:"msg,omitempty"`
}

// V0AppRespModel defines model for v0.AppRespModel.
type V0AppRespModel struct {
	Slug   *string `json:"slug,omitempty"`
	Status *string `json:"status,omitempty"`
}

// V0AppResponseItemModel defines model for v0.AppResponseItemModel.
type V0AppResponseItemModel struct {
	AvatarUrl             *NullsString                 `json:"avatar_url,omitempty"`
	IsDisabled            *bool                        `json:"is_disabled,omitempty"`
	IsGithubChecksEnabled *bool                        `json:"is_github_checks_enabled,omitempty"`
	IsPublic              *bool                        `json:"is_public,omitempty"`
	Owner                 *V0OwnerAccountResponseModel `json:"owner,omitempty"`
	ProjectType           *NullsString                 `json:"project_type,omitempty"`
	Provider              *NullsString                 `json:"provider,omitempty"`
	RepoOwner             *NullsString                 `json:"repo_owner,omitempty"`
	RepoSlug              *NullsString                 `json:"repo_slug,omitempty"`
	RepoUrl               *NullsString                 `json:"repo_url,omitempty"`
	Slug                  *string                      `json:"slug,omitempty"`
	Status                *int                         `json:"status,omitempty"`
	Title                 *string                      `json:"title,omitempty"`
}

// V0AppSecret defines model for v0.AppSecret.
type V0AppSecret struct {
	// ExpandInStepInputs Replace variable in inputs? https://devcenter.bitrise.io/en/references/steps-reference/step-inputs-reference.html#step-input-properties
	ExpandInStepInputs *bool `json:"expand_in_step_inputs,omitempty"`

	// IsExposedForPullRequests Expose for Pull Requests?
	IsExposedForPullRequests *bool `json:"is_exposed_for_pull_requests,omitempty"`

	// IsProtected Secret marked as protected?
	IsProtected *bool `json:"is_protected,omitempty"`

	// Name Name of the secret
	Name *string `json:"name,omitempty"`
}

// V0AppSecretGetValueResponse defines model for v0.AppSecretGetValueResponse.
type V0AppSecretGetValueResponse struct {
	Value *string `json:"value,omitempty"`
}

// V0AppSecretListResponse defines model for v0.AppSecretListResponse.
type V0AppSecretListResponse struct {
	Secrets *[]V0AppSecret `json:"secrets,omitempty"`
}

// V0AppSecretUpsertParams defines model for v0.AppSecretUpsertParams.
type V0AppSecretUpsertParams struct {
	// ExpandInStepInputs Replace variable in inputs? https://devcenter.bitrise.io/en/references/steps-reference/step-inputs-reference.html#step-input-properties
	ExpandInStepInputs *bool `json:"expand_in_step_inputs,omitempty"`

	// IsExposedForPullRequests Expose for Pull Requests?
	IsExposedForPullRequests *bool `json:"is_exposed_for_pull_requests,omitempty"`

	// IsProtected Secret marked as protected?
	IsProtected *bool `json:"is_protected,omitempty"`

	// Value Value of the secret
	Value *string `json:"value,omitempty"`
}

// V0AppShowResponseModel defines model for v0.AppShowResponseModel.
type V0AppShowResponseModel struct {
	Data *V0AppResponseItemModel `json:"data,omitempty"`
}

// V0AppUpdateParams defines model for v0.AppUpdateParams.
type V0AppUpdateParams struct {
	// AppleCredentialUserId The new apple credential user ID (recommendation: use the UI to set this)
	AppleCredentialUserId *int `json:"apple_credential_user_id,omitempty"`

	// AppleCredentialUserSlug The new apple credential user slug (recommendation: use the UI to set this)
	AppleCredentialUserSlug *string `json:"apple_credential_user_slug,omitempty"`

	// DefaultBranch The new default branch for the application.
	DefaultBranch *string `json:"default_branch,omitempty"`

	// IsPublic The new value of whether an application should be publicly visible
	IsPublic *bool `json:"is_public,omitempty"`

	// RepositoryUrl The new repository URL for the application.
	RepositoryUrl *string `json:"repository_url,omitempty"`

	// ServicesCredentialUserId The new service credential user ID (recommendation: use the UI to set this)
	ServicesCredentialUserId *int `json:"services_credential_user_id,omitempty"`

	// Title The new title of the application.
	Title *string `json:"title,omitempty"`
}

// V0AppUpdateRespModel defines model for v0.AppUpdateRespModel.
type V0AppUpdateRespModel struct {
	Status *string `json:"status,omitempty"`
}

// V0AppUploadParams defines model for v0.AppUploadParams.
type V0AppUploadParams struct {
	// DefaultBranchName The default branch of the repository. If it's not specified, it will be `master`.
	DefaultBranchName *string `json:"default_branch_name,omitempty"`

	// GitOwner [Deprecated] You no longer need to provide this field.
	GitOwner *string `json:"git_owner,omitempty"`

	// GitRepoSlug [Deprecated] You no longer need to provide this field.
	GitRepoSlug *string `json:"git_repo_slug,omitempty"`

	// IsPublic If `true` then the repository visibility setting will be public, in case of `false` it will be private
	IsPublic bool `json:"is_public"`

	// ManualApprovalEnabled Toggles whether manual approval should be enabled for the app's builds. If it's not specified, it will be `true`.
	ManualApprovalEnabled *bool `json:"manual_approval_enabled,omitempty"`

	// OrganizationSlug The slug of the organization, who will be the owner of the application. If it's not specified, then the authenticated user will be the owner.
	OrganizationSlug *string `json:"organization_slug,omitempty"`

	// Provider The git provider you are using, it can be `github`, `bitbucket`, `gitlab`, `gitlab-self-hosted` or `custom`
	Provider *string `json:"provider,omitempty"`

	// RepoUrl The URL of your repository
	RepoUrl string `json:"repo_url"`

	// Title The title of the application. If it's not specified, it will be the git repository's name.
	Title *string `json:"title,omitempty"`

	// Type [Deprecated] You no longer need to provide this field.
	Type *string `json:"type,omitempty"`
}

// V0AppWebhookCreateParams defines model for v0.AppWebhookCreateParams.
type V0AppWebhookCreateParams struct {
	Events  []string `json:"events"`
	Headers *[]int   `json:"headers,omitempty"`
	Secret  string   `json:"secret"`
	Url     string   `json:"url"`
}

// V0AppWebhookCreatedResponseModel defines model for v0.AppWebhookCreatedResponseModel.
type V0AppWebhookCreatedResponseModel struct {
	Data *V0AppWebhookResponseItemModel `json:"data,omitempty"`
}

// V0AppWebhookDeletedResponseModel defines model for v0.AppWebhookDeletedResponseModel.
type V0AppWebhookDeletedResponseModel struct {
	Data *V0AppWebhookResponseItemModel `json:"data,omitempty"`
}

// V0AppWebhookListResponseModel defines model for v0.AppWebhookListResponseModel.
type V0AppWebhookListResponseModel struct {
	Data *[]V0AppWebhookResponseItemModel `json:"data,omitempty"`

	// Paging pagination
	Paging *V0PagingResponseModel `json:"paging,omitempty"`
}

// V0AppWebhookResponseItemModel defines model for v0.AppWebhookResponseItemModel.
type V0AppWebhookResponseItemModel struct {
	CreatedAt         *string   `json:"created_at,omitempty"`
	Events            *[]string `json:"events,omitempty"`
	Headers           *[]int    `json:"headers,omitempty"`
	RegisteredByAddon *bool     `json:"registered_by_addon,omitempty"`
	Slug              *string   `json:"slug,omitempty"`
	UpdatedAt         *string   `json:"updated_at,omitempty"`
	Url               *string   `json:"url,omitempty"`
}

// V0AppWebhookResponseModel defines model for v0.AppWebhookResponseModel.
type V0AppWebhookResponseModel struct {
	Data *V0AppWebhookResponseItemModel `json:"data,omitempty"`
}

// V0AppWebhookUpdateParams defines model for v0.AppWebhookUpdateParams.
type V0AppWebhookUpdateParams struct {
	Events  []string `json:"events"`
	Headers *[]int   `json:"headers,omitempty"`
	Url     string   `json:"url"`
}

// V0AppleAPICredentialResponseItem defines model for v0.AppleAPICredentialResponseItem.
type V0AppleAPICredentialResponseItem struct {
	CreatedAt *string `json:"created_at,omitempty"`
	IssuerId  *string `json:"issuer_id,omitempty"`
	KeyId     *string `json:"key_id,omitempty"`
	Name      *string `json:"name,omitempty"`
	Slug      *string `json:"slug,omitempty"`
	UpdatedAt *string `json:"updated_at,omitempty"`
}

// V0AppleAPICredentialsListResponse defines model for v0.AppleAPICredentialsListResponse.
type V0AppleAPICredentialsListResponse struct {
	Data *[]V0AppleAPICredentialResponseItem `json:"data,omitempty"`
}

// V0ArchivedBuildArtifact defines model for v0.ArchivedBuildArtifact.
type V0ArchivedBuildArtifact struct {
	ArtifactMeta        *map[string]interface{} `json:"artifact_meta,omitempty"`
	ArtifactType        *string                 `json:"artifact_type,omitempty"`
	CreatedAt           *string                 `json:"created_at,omitempty"`
	FileSizeBytes       *int                    `json:"file_size_bytes,omitempty"`
	Id                  *string                 `json:"id,omitempty"`
	IsPublicPageEnabled *bool                   `json:"is_public_page_enabled,omitempty"`
	PublicPageToken     *string                 `json:"public_page_token,omitempty"`
	Title               *string                 `json:"title,omitempty"`
}

// V0ArchivedBuildListResponseModel defines model for v0.ArchivedBuildListResponseModel.
type V0ArchivedBuildListResponseModel struct {
	Data *[]V0ArchivedBuildResponseItemModel `json:"data,omitempty"`

	// Paging pagination
	Paging *V0PagingResponseModel `json:"paging,omitempty"`
}

// V0ArchivedBuildResponseItemModel defines model for v0.ArchivedBuildResponseItemModel.
type V0ArchivedBuildResponseItemModel struct {
	AbortReason             *string                    `json:"abort_reason,omitempty"`
	Branch                  *string                    `json:"branch,omitempty"`
	BuildArtifacts          *[]V0ArchivedBuildArtifact `json:"build_artifacts,omitempty"`
	BuildNumber             *int                       `json:"build_number,omitempty"`
	CommitHash              *string                    `json:"commit_hash,omitempty"`
	CommitMessage           *string                    `json:"commit_message,omitempty"`
	CreditCost              *int                       `json:"credit_cost,omitempty"`
	FinishedAt              *string                    `json:"finished_at,omitempty"`
	MachineTypeId           *string                    `json:"machine_type_id,omitempty"`
	OriginalBuildParams     *[]int                     `json:"original_build_params,omitempty"`
	PipelineWorkflowId      *string                    `json:"pipeline_workflow_id,omitempty"`
	PullRequestId           *int                       `json:"pull_request_id,omitempty"`
	PullRequestTargetBranch *string                    `json:"pull_request_target_branch,omitempty"`
	PullRequestViewUrl      *string                    `json:"pull_request_view_url,omitempty"`
	Slug                    *string                    `json:"slug,omitempty"`
	StackIdentifier         *string                    `json:"stack_identifier,omitempty"`
	StartedOnWorkerAt       *string                    `json:"started_on_worker_at,omitempty"`
	Status                  *int                       `json:"status,omitempty"`
	StatusText              *string                    `json:"status_text,omitempty"`
	Tag                     *string                    `json:"tag,omitempty"`
	TriggeredBy             *string                    `json:"triggered_by,omitempty"`
	TriggeredWorkflow       *string                    `json:"triggered_workflow,omitempty"`
}

// V0ArtifactDeleteResponseModel defines model for v0.ArtifactDeleteResponseModel.
type V0ArtifactDeleteResponseModel struct {
	Data *V0ArtifactResponseItemModel `json:"data,omitempty"`
}

// V0ArtifactListElementResponseModel defines model for v0.ArtifactListElementResponseModel.
type V0ArtifactListElementResponseModel struct {
	ArtifactMeta         *[]int       `json:"artifact_meta,omitempty"`
	ArtifactType         *NullsString `json:"artifact_type,omitempty"`
	FileSizeBytes        *int         `json:"file_size_bytes,omitempty"`
	IntermediateFileInfo *[]int       `json:"intermediate_file_info,omitempty"`
	IsPublicPageEnabled  *bool        `json:"is_public_page_enabled,omitempty"`
	Slug                 *string      `json:"slug,omitempty"`
	Title                *NullsString `json:"title,omitempty"`
}

// V0ArtifactListResponseModel defines model for v0.ArtifactListResponseModel.
type V0ArtifactListResponseModel struct {
	Data *[]V0ArtifactListElementResponseModel `json:"data,omitempty"`

	// Paging pagination
	Paging *V0PagingResponseModel `json:"paging,omitempty"`
}

// V0ArtifactResponseItemModel defines model for v0.ArtifactResponseItemModel.
type V0ArtifactResponseItemModel struct {
	ArtifactMeta         *[]int       `json:"artifact_meta,omitempty"`
	ArtifactType         *NullsString `json:"artifact_type,omitempty"`
	ExpiringDownloadUrl  *string      `json:"expiring_download_url,omitempty"`
	FileSizeBytes        *int         `json:"file_size_bytes,omitempty"`
	IntermediateFileInfo *[]int       `json:"intermediate_file_info,omitempty"`
	IsPublicPageEnabled  *bool        `json:"is_public_page_enabled,omitempty"`
	PublicInstallPageUrl *string      `json:"public_install_page_url,omitempty"`
	Slug                 *string      `json:"slug,omitempty"`
	Title                *NullsString `json:"title,omitempty"`
}

// V0ArtifactShowResponseModel defines model for v0.ArtifactShowResponseModel.
type V0ArtifactShowResponseModel struct {
	Data *V0ArtifactResponseItemModel `json:"data,omitempty"`
}

// V0ArtifactUpdateParams defines model for v0.ArtifactUpdateParams.
type V0ArtifactUpdateParams struct {
	IsPublicPageEnabled bool `json:"is_public_page_enabled"`
}

// V0BitriseYMLConfigGetResponse defines model for v0.BitriseYMLConfigGetResponse.
type V0BitriseYMLConfigGetResponse struct {
	// Location Location of bitrise.yml file. Enums(bitrise.io, repository)
	Location *WebsiteBitriseYMLLocation `json:"location,omitempty"`
}

// V0BitriseYMLConfigUpdateParams defines model for v0.BitriseYMLConfigUpdateParams.
type V0BitriseYMLConfigUpdateParams struct {
	// Location Location of bitrise.yml file. Enums(bitrise.io, repository)
	Location *WebsiteBitriseYMLLocation `json:"location,omitempty"`
}

// V0BranchListResponseModel defines model for v0.BranchListResponseModel.
type V0BranchListResponseModel struct {
	Data *[]string `json:"data,omitempty"`
}

// V0BuildAbortParams defines model for v0.BuildAbortParams.
type V0BuildAbortParams struct {
	AbortReason       string `json:"abort_reason"`
	AbortWithSuccess  bool   `json:"abort_with_success"`
	SkipNotifications bool   `json:"skip_notifications"`
}

// V0BuildAbortResponseModel defines model for v0.BuildAbortResponseModel.
type V0BuildAbortResponseModel struct {
	Status *string `json:"status,omitempty"`
}

// V0BuildCertificateListResponseModel defines model for v0.BuildCertificateListResponseModel.
type V0BuildCertificateListResponseModel struct {
	Data *[]V0BuildCertificateResponseItemModel `json:"data,omitempty"`

	// Paging pagination
	Paging *V0PagingResponseModel `json:"paging,omitempty"`
}

// V0BuildCertificateResponseItemModel defines model for v0.BuildCertificateResponseItemModel.
type V0BuildCertificateResponseItemModel struct {
	CertificatePassword *string `json:"certificate_password,omitempty"`
	DownloadUrl         *string `json:"download_url,omitempty"`
	IsExpose            *bool   `json:"is_expose,omitempty"`
	IsProtected         *bool   `json:"is_protected,omitempty"`
	Processed           *bool   `json:"processed,omitempty"`
	Slug                *string `json:"slug,omitempty"`
	UploadFileName      *string `json:"upload_file_name,omitempty"`
	UploadFileSize      *int    `json:"upload_file_size,omitempty"`
	UploadUrl           *string `json:"upload_url,omitempty"`
}

// V0BuildCertificateResponseModel defines model for v0.BuildCertificateResponseModel.
type V0BuildCertificateResponseModel struct {
	Data *V0BuildCertificateResponseItemModel `json:"data,omitempty"`
}

// V0BuildCertificateUpdateParams defines model for v0.BuildCertificateUpdateParams.
type V0BuildCertificateUpdateParams struct {
	CertificatePassword *string `json:"certificate_password,omitempty"`
	IsExpose            *bool   `json:"is_expose,omitempty"`
	IsProtected         *bool   `json:"is_protected,omitempty"`
	Processed           *bool   `json:"processed,omitempty"`
}

// V0BuildCertificateUploadParams defines model for v0.BuildCertificateUploadParams.
type V0BuildCertificateUploadParams struct {
	UploadFileName string `json:"upload_file_name"`
	UploadFileSize int    `json:"upload_file_size"`
}

// V0BuildListAllResponseItemModel defines model for v0.BuildListAllResponseItemModel.
type V0BuildListAllResponseItemModel struct {
	AbortReason                  *NullsString            `json:"abort_reason,omitempty"`
	Branch                       *NullsString            `json:"branch,omitempty"`
	BuildNumber                  *int                    `json:"build_number,omitempty"`
	CommitHash                   *NullsString            `json:"commit_hash,omitempty"`
	CommitMessage                *NullsString            `json:"commit_message,omitempty"`
	CommitViewUrl                *NullsString            `json:"commit_view_url,omitempty"`
	CreditCost                   *NullsInt64             `json:"credit_cost,omitempty"`
	EnvironmentPrepareFinishedAt *string                 `json:"environment_prepare_finished_at,omitempty"`
	FinishedAt                   *string                 `json:"finished_at,omitempty"`
	IsOnHold                     *bool                   `json:"is_on_hold,omitempty"`
	IsProcessed                  *bool                   `json:"is_processed,omitempty"`
	MachineTypeId                *NullsString            `json:"machine_type_id,omitempty"`
	OriginalBuildParams          *[]int                  `json:"original_build_params,omitempty"`
	PullRequestId                *int                    `json:"pull_request_id,omitempty"`
	PullRequestTargetBranch      *NullsString            `json:"pull_request_target_branch,omitempty"`
	PullRequestViewUrl           *NullsString            `json:"pull_request_view_url,omitempty"`
	Repository                   *V0AppResponseItemModel `json:"repository,omitempty"`
	Slug                         *string                 `json:"slug,omitempty"`
	StackIdentifier              *NullsString            `json:"stack_identifier,omitempty"`
	StartedOnWorkerAt            *string                 `json:"started_on_worker_at,omitempty"`
	Status                       *int                    `json:"status,omitempty"`
	StatusText                   *string                 `json:"status_text,omitempty"`
	Tag                          *NullsString            `json:"tag,omitempty"`
	TriggeredAt                  *string                 `json:"triggered_at,omitempty"`
	TriggeredBy                  *NullsString            `json:"triggered_by,omitempty"`
	TriggeredWorkflow            *string                 `json:"triggered_workflow,omitempty"`
}

// V0BuildListAllResponseModel defines model for v0.BuildListAllResponseModel.
type V0BuildListAllResponseModel struct {
	Data *[]V0BuildListAllResponseItemModel `json:"data,omitempty"`

	// Paging pagination
	Paging *V0PagingResponseModel `json:"paging,omitempty"`
}

// V0BuildListResponseModel defines model for v0.BuildListResponseModel.
type V0BuildListResponseModel struct {
	Data *[]V0BuildResponseItemModel `json:"data,omitempty"`

	// Paging pagination
	Paging *V0PagingResponseModel `json:"paging,omitempty"`
}

// V0BuildParamsEnvironment defines model for v0.BuildParamsEnvironment.
type V0BuildParamsEnvironment struct {
	IsExpand *bool   `json:"is_expand,omitempty"`
	MappedTo *string `json:"mapped_to,omitempty"`
	Value    *string `json:"value,omitempty"`
}

// V0BuildRequestListResponseModel defines model for v0.BuildRequestListResponseModel.
type V0BuildRequestListResponseModel struct {
	Data *[]V0BuildRequestResponseItemModel `json:"data,omitempty"`
}

// V0BuildRequestResponseItemModel defines model for v0.BuildRequestResponseItemModel.
type V0BuildRequestResponseItemModel struct {
	BuildParams    *[]int  `json:"build_params,omitempty"`
	CreatedAt      *string `json:"created_at,omitempty"`
	PullRequestUrl *string `json:"pull_request_url,omitempty"`
	Slug           *string `json:"slug,omitempty"`
}

// V0BuildRequestUpdateParams defines model for v0.BuildRequestUpdateParams.
type V0BuildRequestUpdateParams struct {
	IsApproved bool `json:"is_approved"`
}

// V0BuildRequestUpdateResponseModel defines model for v0.BuildRequestUpdateResponseModel.
type V0BuildRequestUpdateResponseModel struct {
	Data *V0BuildRequestResponseItemModel `json:"data,omitempty"`
}

// V0BuildResponseItemModel defines model for v0.BuildResponseItemModel.
type V0BuildResponseItemModel struct {
	AbortReason                  *NullsString `json:"abort_reason,omitempty"`
	Branch                       *NullsString `json:"branch,omitempty"`
	BuildNumber                  *int         `json:"build_number,omitempty"`
	CommitHash                   *NullsString `json:"commit_hash,omitempty"`
	CommitMessage                *NullsString `json:"commit_message,omitempty"`
	CommitViewUrl                *NullsString `json:"commit_view_url,omitempty"`
	CreditCost                   *NullsInt64  `json:"credit_cost,omitempty"`
	EnvironmentPrepareFinishedAt *string      `json:"environment_prepare_finished_at,omitempty"`
	FinishedAt                   *string      `json:"finished_at,omitempty"`
	IsOnHold                     *bool        `json:"is_on_hold,omitempty"`
	IsProcessed                  *bool        `json:"is_processed,omitempty"`
	IsStatusSent                 *bool        `json:"is_status_sent,omitempty"`
	LogFormat                    *string      `json:"log_format,omitempty"`
	MachineTypeId                *NullsString `json:"machine_type_id,omitempty"`
	OriginalBuildParams          *[]int       `json:"original_build_params,omitempty"`
	PipelineWorkflowId           *string      `json:"pipeline_workflow_id,omitempty"`
	PullRequestId                *int         `json:"pull_request_id,omitempty"`
	PullRequestTargetBranch      *NullsString `json:"pull_request_target_branch,omitempty"`
	PullRequestViewUrl           *NullsString `json:"pull_request_view_url,omitempty"`
	Slug                         *string      `json:"slug,omitempty"`
	StackIdentifier              *NullsString `json:"stack_identifier,omitempty"`
	StartedOnWorkerAt            *string      `json:"started_on_worker_at,omitempty"`
	Status                       *int         `json:"status,omitempty"`
	StatusText                   *string      `json:"status_text,omitempty"`
	Tag                          *NullsString `json:"tag,omitempty"`
	TriggeredAt                  *string      `json:"triggered_at,omitempty"`
	TriggeredBy                  *NullsString `json:"triggered_by,omitempty"`
	TriggeredWorkflow            *string      `json:"triggered_workflow,omitempty"`
}

// V0BuildShowResponseModel defines model for v0.BuildShowResponseModel.
type V0BuildShowResponseModel struct {
	Data *V0BuildResponseItemModel `json:"data,omitempty"`
}

// V0BuildTriggerParams defines model for v0.BuildTriggerParams.
type V0BuildTriggerParams struct {
	// BuildParams The public part of the SSH key you would like to use
	BuildParams *V0BuildTriggerParamsBuildParams `json:"build_params,omitempty"`
	HookInfo    *V0BuildTriggerParamsHookInfo    `json:"hook_info,omitempty"`
}

// V0BuildTriggerParamsBuildParams defines model for v0.BuildTriggerParamsBuildParams.
type V0BuildTriggerParamsBuildParams struct {
	BaseRepositoryUrl                *string                     `json:"base_repository_url,omitempty"`
	Branch                           *string                     `json:"branch,omitempty"`
	BranchDest                       *string                     `json:"branch_dest,omitempty"`
	BranchDestRepoOwner              *string                     `json:"branch_dest_repo_owner,omitempty"`
	BranchRepoOwner                  *string                     `json:"branch_repo_owner,omitempty"`
	BuildRequestSlug                 *string                     `json:"build_request_slug,omitempty"`
	CommitHash                       *string                     `json:"commit_hash,omitempty"`
	CommitMessage                    *string                     `json:"commit_message,omitempty"`
	CommitPaths                      *[]V0CommitPaths            `json:"commit_paths,omitempty"`
	DiffUrl                          *string                     `json:"diff_url,omitempty"`
	Environments                     *[]V0BuildParamsEnvironment `json:"environments,omitempty"`
	HeadRepositoryUrl                *string                     `json:"head_repository_url,omitempty"`
	PipelineId                       *string                     `json:"pipeline_id,omitempty"`
	PullRequestAuthor                *string                     `json:"pull_request_author,omitempty"`
	PullRequestHeadBranch            *string                     `json:"pull_request_head_branch,omitempty"`
	PullRequestId                    *map[string]interface{}     `json:"pull_request_id,omitempty"`
	PullRequestMergeBranch           *string                     `json:"pull_request_merge_branch,omitempty"`
	PullRequestRepositoryUrl         *string                     `json:"pull_request_repository_url,omitempty"`
	PullRequestUnverifiedMergeBranch *string                     `json:"pull_request_unverified_merge_branch,omitempty"`
	SkipGitStatusReport              *bool                       `json:"skip_git_status_report,omitempty"`
	Tag                              *string                     `json:"tag,omitempty"`
	WorkflowId                       *string                     `json:"workflow_id,omitempty"`
}

// V0BuildTriggerParamsHookInfo defines model for v0.BuildTriggerParamsHookInfo.
type V0BuildTriggerParamsHookInfo struct {
	// Type Should be "bitrise"
	Type *string `json:"type,omitempty"`
}

// V0BuildTriggerRespModel defines model for v0.BuildTriggerRespModel.
type V0BuildTriggerRespModel struct {
	BuildNumber       *int    `json:"build_number,omitempty"`
	BuildSlug         *string `json:"build_slug,omitempty"`
	BuildUrl          *string `json:"build_url,omitempty"`
	Message           *string `json:"message,omitempty"`
	Service           *string `json:"service,omitempty"`
	Slug              *string `json:"slug,omitempty"`
	Status            *string `json:"status,omitempty"`
	TriggeredWorkflow *string `json:"triggered_workflow,omitempty"`
}

// V0BuildWorkflowListResponseModel defines model for v0.BuildWorkflowListResponseModel.
type V0BuildWorkflowListResponseModel struct {
	Data *[]string `json:"data,omitempty"`
}

// V0CacheItemDownloadResponseModel defines model for v0.CacheItemDownloadResponseModel.
type V0CacheItemDownloadResponseModel struct {
	Data *V0CacheItemDownloadURLResponseModel `json:"data,omitempty"`
}

// V0CacheItemDownloadURLResponseModel defines model for v0.CacheItemDownloadURLResponseModel.
type V0CacheItemDownloadURLResponseModel struct {
	DownloadUrl *string `json:"download_url,omitempty"`
}

// V0CacheItemListResponseItemModel defines model for v0.CacheItemListResponseItemModel.
type V0CacheItemListResponseItemModel struct {
	AppId           *string `json:"app_id,omitempty"`
	ArchiveFilename *string `json:"archive_filename,omitempty"`
	ArchiveSize     *int    `json:"archive_size,omitempty"`
	CacheKey        *string `json:"cache_key,omitempty"`
	CreatedAt       *string `json:"created_at,omitempty"`
	ExpiresAt       *string `json:"expires_at,omitempty"`
	Id              *string `json:"id,omitempty"`
	LastUsedAt      *string `json:"last_used_at,omitempty"`
}

// V0CacheItemListResponseModel defines model for v0.CacheItemListResponseModel.
type V0CacheItemListResponseModel struct {
	Data   *[]V0CacheItemListResponseItemModel `json:"data,omitempty"`
	Paging *V0PagingResponseModel              `json:"paging,omitempty"`
}

// V0CommitPaths defines model for v0.CommitPaths.
type V0CommitPaths struct {
	Added    *[]string `json:"added,omitempty"`
	Modified *[]string `json:"modified,omitempty"`
	Removed  *[]string `json:"removed,omitempty"`
}

// V0OrganizationDataModel defines model for v0.OrganizationDataModel.
type V0OrganizationDataModel struct {
	AvatarIconUrl    *NullsString           `json:"avatar_icon_url,omitempty"`
	ConcurrencyCount *int                   `json:"concurrency_count,omitempty"`
	Name             *string                `json:"name,omitempty"`
	Owners           *[]V0OrganizationOwner `json:"owners,omitempty"`
	Slug             *string                `json:"slug,omitempty"`
}

// V0OrganizationListRespModel defines model for v0.OrganizationListRespModel.
type V0OrganizationListRespModel struct {
	Data *[]V0OrganizationDataModel `json:"data,omitempty"`
}

// V0OrganizationOwner defines model for v0.OrganizationOwner.
type V0OrganizationOwner struct {
	Email    *string `json:"email,omitempty"`
	Slug     *string `json:"slug,omitempty"`
	Username *string `json:"username,omitempty"`
}

// V0OrganizationRespModel defines model for v0.OrganizationRespModel.
type V0OrganizationRespModel struct {
	Data *V0OrganizationDataModel `json:"data,omitempty"`
}

// V0OrganizationUpdateMachineTypeParams defines model for v0.OrganizationUpdateMachineTypeParams.
type V0OrganizationUpdateMachineTypeParams struct {
	// FromMachine Machine type to migrate from
	FromMachine *string `json:"from_machine,omitempty"`

	// ToMachine Machine type to migrate to
	ToMachine *string `json:"to_machine,omitempty"`
}

// V0OrganizationUpdateMachineTypeResponse defines model for v0.OrganizationUpdateMachineTypeResponse.
type V0OrganizationUpdateMachineTypeResponse struct {
	Errors *[]V0OrganizationUpdateMachineTypeResponseErrorsInner `json:"errors,omitempty"`

	// Message The result of the migration
	Message *string `json:"message,omitempty"`

	// MigratedApps The migrated apps' identifiers in the following format "#{app.title} (#{app.slug})"
	MigratedApps *[]string `json:"migrated_apps,omitempty"`
}

// V0OwnerAccountResponseModel defines model for v0.OwnerAccountResponseModel.
type V0OwnerAccountResponseModel struct {
	AccountType *string `json:"account_type,omitempty"`
	Name        *string `json:"name,omitempty"`
	Slug        *string `json:"slug,omitempty"`
}

// V0OwnerAddOnResponseItemModel defines model for v0.OwnerAddOnResponseItemModel.
type V0OwnerAddOnResponseItemModel struct {
	Apps             *[]V0AddOnAppResponseItemModel `json:"apps,omitempty"`
	DocumentationUrl *string                        `json:"documentation_url,omitempty"`
	HasUi            *bool                          `json:"has_ui,omitempty"`
	Icon             *string                        `json:"icon,omitempty"`
	Id               *string                        `json:"id,omitempty"`
	IsBeta           *bool                          `json:"is_beta,omitempty"`
	Summary          *string                        `json:"summary,omitempty"`
	Title            *string                        `json:"title,omitempty"`
}

// V0OwnerAddOnsListResponseModel defines model for v0.OwnerAddOnsListResponseModel.
type V0OwnerAddOnsListResponseModel struct {
	Data *[]V0OwnerAddOnResponseItemModel `json:"data,omitempty"`
}

// V0PagingResponseModel defines model for v0.PagingResponseModel.
type V0PagingResponseModel struct {
	// Next Next is the "anchor" for pagination. This value should be passed to the same endpoint
	// to get the next page. Empty/not included if there's no "next" page.
	// Stop paging when there's no "Next" item in the response!
	Next *string `json:"next,omitempty"`

	// PageItemLimit PageItemLimit - per-page item count. A given page might include
	// less items if there's not enough items. This value is the "max item count per page".
	PageItemLimit *int `json:"page_item_limit,omitempty"`

	// TotalItemCount TotalItemCount - total item count, through "all pages"
	TotalItemCount *int `json:"total_item_count,omitempty"`
}

// V0PipelineAbortParams defines model for v0.PipelineAbortParams.
type V0PipelineAbortParams struct {
	AbortReason       string `json:"abort_reason"`
	AbortWithSuccess  bool   `json:"abort_with_success"`
	SkipNotifications bool   `json:"skip_notifications"`
}

// V0PipelineListAllResponseItemModel defines model for v0.PipelineListAllResponseItemModel.
type V0PipelineListAllResponseItemModel struct {
	Branch                  *NullsString            `json:"branch,omitempty"`
	BuildNumber             *int                    `json:"build_number,omitempty"`
	CommitHash              *NullsString            `json:"commit_hash,omitempty"`
	CommitMessage           *NullsString            `json:"commit_message,omitempty"`
	CreditCost              *NullsInt64             `json:"credit_cost,omitempty"`
	FinishedAt              *string                 `json:"finished_at,omitempty"`
	IsOnHold                *bool                   `json:"is_on_hold,omitempty"`
	IsPipeline              *bool                   `json:"is_pipeline,omitempty"`
	IsProcessed             *bool                   `json:"is_processed,omitempty"`
	PullRequestId           *int                    `json:"pull_request_id,omitempty"`
	PullRequestTargetBranch *NullsString            `json:"pull_request_target_branch,omitempty"`
	Repository              *V0AppResponseItemModel `json:"repository,omitempty"`
	Slug                    *string                 `json:"slug,omitempty"`
	StartedAt               *string                 `json:"started_at,omitempty"`
	Status                  *int                    `json:"status,omitempty"`
	Tag                     *NullsString            `json:"tag,omitempty"`
	TriggeredAt             *string                 `json:"triggered_at,omitempty"`
	TriggeredBy             *NullsString            `json:"triggered_by,omitempty"`
	TriggeredWorkflow       *string                 `json:"triggered_workflow,omitempty"`
}

// V0PipelineListAllResponseModel defines model for v0.PipelineListAllResponseModel.
type V0PipelineListAllResponseModel struct {
	Data   *[]V0PipelineListAllResponseItemModel `json:"data,omitempty"`
	Paging *V0PagingResponseModel                `json:"paging,omitempty"`
}

// V0PipelineListResponseItemModel defines model for v0.PipelineListResponseItemModel.
type V0PipelineListResponseItemModel struct {
	Artifacts               *[]PipelineabledomainArtifactMeta        `json:"artifacts,omitempty"`
	Branch                  *NullsString                             `json:"branch,omitempty"`
	BuildNumber             *int                                     `json:"build_number,omitempty"`
	BuildToolInvocations    *[]PipelineabledomainBuildToolInvocation `json:"build_tool_invocations,omitempty"`
	CommitHash              *NullsString                             `json:"commit_hash,omitempty"`
	CommitMessage           *NullsString                             `json:"commit_message,omitempty"`
	CreditCost              *NullsInt64                              `json:"credit_cost,omitempty"`
	FinishedAt              *string                                  `json:"finished_at,omitempty"`
	IsOnHold                *bool                                    `json:"is_on_hold,omitempty"`
	IsPipeline              *bool                                    `json:"is_pipeline,omitempty"`
	IsProcessed             *bool                                    `json:"is_processed,omitempty"`
	LocalConfig             *PipelineabledomainLocalConfig           `json:"local_config,omitempty"`
	PullRequestId           *int                                     `json:"pull_request_id,omitempty"`
	PullRequestTargetBranch *NullsString                             `json:"pull_request_target_branch,omitempty"`
	Slug                    *string                                  `json:"slug,omitempty"`
	StartedAt               *string                                  `json:"started_at,omitempty"`
	Status                  *int                                     `json:"status,omitempty"`
	Tag                     *NullsString                             `json:"tag,omitempty"`
	TriggerParams           *PipelineabledomainTriggerParams         `json:"trigger_params,omitempty"`
	TriggeredAt             *string                                  `json:"triggered_at,omitempty"`
	TriggeredBy             *NullsString                             `json:"triggered_by,omitempty"`
	TriggeredWorkflow       *string                                  `json:"triggered_workflow,omitempty"`
}

// V0PipelineListResponseModel defines model for v0.PipelineListResponseModel.
type V0PipelineListResponseModel struct {
	Data *[]V0PipelineListResponseItemModel `json:"data,omitempty"`

	// Paging pagination
	Paging *V0PagingResponseModel `json:"paging,omitempty"`
}

// V0PipelineRebuildParams defines model for v0.PipelineRebuildParams.
type V0PipelineRebuildParams struct {
	Partial     *bool   `json:"partial,omitempty"`
	TriggeredBy *string `json:"triggered_by,omitempty"`
}

// V0PipelineShowAppResponseModel defines model for v0.PipelineShowAppResponseModel.
type V0PipelineShowAppResponseModel struct {
	Slug *string `json:"slug,omitempty"`
}

// V0PipelineShowAttemptResponseModel defines model for v0.PipelineShowAttemptResponseModel.
type V0PipelineShowAttemptResponseModel struct {
	Id                         *string `json:"id,omitempty"`
	NumberInPipelineBuildScope *int    `json:"number_in_pipeline_build_scope,omitempty"`
	Status                     *string `json:"status,omitempty"`
	TriggeredAt                *string `json:"triggered_at,omitempty"`
}

// V0PipelineShowEnvironmentsResponseModel defines model for v0.PipelineShowEnvironmentsResponseModel.
type V0PipelineShowEnvironmentsResponseModel struct {
	IsExpand *bool                   `json:"is_expand,omitempty"`
	Key      *string                 `json:"key,omitempty"`
	Value    *map[string]interface{} `json:"value,omitempty"`
}

// V0PipelineShowResponseModel defines model for v0.PipelineShowResponseModel.
type V0PipelineShowResponseModel struct {
	AbortReason      *string                                   `json:"abort_reason,omitempty"`
	App              *V0PipelineShowAppResponseModel           `json:"app,omitempty"`
	Attempts         *[]V0PipelineShowAttemptResponseModel     `json:"attempts,omitempty"`
	CreditCost       *map[string]interface{}                   `json:"credit_cost,omitempty"`
	CurrentAttemptId *string                                   `json:"current_attempt_id,omitempty"`
	FinishedAt       *string                                   `json:"finished_at,omitempty"`
	Id               *string                                   `json:"id,omitempty"`
	Name             *string                                   `json:"name,omitempty"`
	NumberInAppScope *int                                      `json:"number_in_app_scope,omitempty"`
	PutOnHoldAt      *map[string]interface{}                   `json:"put_on_hold_at,omitempty"`
	Stages           *[]V0PipelineShowStageResponseModel       `json:"stages,omitempty"`
	StartedAt        *string                                   `json:"started_at,omitempty"`
	Status           *V0PipelineShowResponseModelStatus        `json:"status,omitempty"`
	TriggerParams    *V0PipelineShowTriggerParamsResponseModel `json:"trigger_params,omitempty"`
	TriggeredAt      *string                                   `json:"triggered_at,omitempty"`
	TriggeredBy      *string                                   `json:"triggered_by,omitempty"`
}

// V0PipelineShowResponseModelStatus defines model for V0PipelineShowResponseModel.Status.
type V0PipelineShowResponseModelStatus string

// V0PipelineShowStageResponseModel defines model for v0.PipelineShowStageResponseModel.
type V0PipelineShowStageResponseModel struct {
	Id        *string                                `json:"id,omitempty"`
	Name      *string                                `json:"name,omitempty"`
	Workflows *[]V0PipelineShowWorkflowResponseModel `json:"workflows,omitempty"`
}

// V0PipelineShowTriggerParamsResponseModel defines model for v0.PipelineShowTriggerParamsResponseModel.
type V0PipelineShowTriggerParamsResponseModel struct {
	Branch                           *string                                    `json:"branch,omitempty"`
	BranchDest                       *string                                    `json:"branch_dest,omitempty"`
	BranchDestRepoOwner              *string                                    `json:"branch_dest_repo_owner,omitempty"`
	BranchRepoOwner                  *string                                    `json:"branch_repo_owner,omitempty"`
	CommitHash                       *string                                    `json:"commit_hash,omitempty"`
	CommitMessage                    *string                                    `json:"commit_message,omitempty"`
	Environments                     *[]V0PipelineShowEnvironmentsResponseModel `json:"environments,omitempty"`
	PullRequestAuthor                *string                                    `json:"pull_request_author,omitempty"`
	PullRequestHeadBranch            *string                                    `json:"pull_request_head_branch,omitempty"`
	PullRequestId                    *string                                    `json:"pull_request_id,omitempty"`
	PullRequestMergeBranch           *string                                    `json:"pull_request_merge_branch,omitempty"`
	PullRequestRepositoryUrl         *string                                    `json:"pull_request_repository_url,omitempty"`
	PullRequestUnverifiedMergeBranch *string                                    `json:"pull_request_unverified_merge_branch,omitempty"`
	Tag                              *string                                    `json:"tag,omitempty"`
}

// V0PipelineShowWorkflowResponseModel defines model for v0.PipelineShowWorkflowResponseModel.
type V0PipelineShowWorkflowResponseModel struct {
	CreditCost         *map[string]interface{} `json:"credit_cost,omitempty"`
	ExternalId         *string                 `json:"external_id,omitempty"`
	FinishedAt         *string                 `json:"finished_at,omitempty"`
	Id                 *string                 `json:"id,omitempty"`
	Name               *string                 `json:"name,omitempty"`
	StartFailureReason *string                 `json:"startFailureReason,omitempty"`
	StartedAt          *string                 `json:"started_at,omitempty"`
	Status             *string                 `json:"status,omitempty"`
}

// V0PlanDataModel defines model for v0.PlanDataModel.
type V0PlanDataModel struct {
	ContainerCount *int        `json:"container_count,omitempty"`
	ExpiresAt      *string     `json:"expires_at,omitempty"`
	Id             *string     `json:"id,omitempty"`
	Name           *string     `json:"name,omitempty"`
	Price          *NullsInt64 `json:"price,omitempty"`
}

// V0ProjectFileStorageDocumentUpdateParams defines model for v0.ProjectFileStorageDocumentUpdateParams.
type V0ProjectFileStorageDocumentUpdateParams struct {
	ExposedMetaDatastore *[]int  `json:"exposed_meta_datastore,omitempty"`
	IsExpose             *bool   `json:"is_expose,omitempty"`
	IsProtected          *bool   `json:"is_protected,omitempty"`
	Processed            *bool   `json:"processed,omitempty"`
	UserEnvKey           *string `json:"user_env_key,omitempty"`
}

// V0ProjectFileStorageListResponseModel defines model for v0.ProjectFileStorageListResponseModel.
type V0ProjectFileStorageListResponseModel struct {
	Data *[]V0ProjectFileStorageResponseItemModel `json:"data,omitempty"`

	// Paging pagination
	Paging *V0PagingResponseModel `json:"paging,omitempty"`
}

// V0ProjectFileStorageResponseItemModel defines model for v0.ProjectFileStorageResponseItemModel.
type V0ProjectFileStorageResponseItemModel struct {
	DownloadUrl          *string `json:"download_url,omitempty"`
	ExposedMetaDatastore *[]int  `json:"exposed_meta_datastore,omitempty"`
	IsExpose             *bool   `json:"is_expose,omitempty"`
	IsProtected          *bool   `json:"is_protected,omitempty"`
	Processed            *bool   `json:"processed,omitempty"`
	Slug                 *string `json:"slug,omitempty"`
	UploadFileName       *string `json:"upload_file_name,omitempty"`
	UploadFileSize       *int    `json:"upload_file_size,omitempty"`
	UploadUrl            *string `json:"upload_url,omitempty"`
	UserEnvKey           *string `json:"user_env_key,omitempty"`
}

// V0ProjectFileStorageResponseModel defines model for v0.ProjectFileStorageResponseModel.
type V0ProjectFileStorageResponseModel struct {
	Data *V0ProjectFileStorageResponseItemModel `json:"data,omitempty"`
}

// V0ProjectFileStorageUploadParams defines model for v0.ProjectFileStorageUploadParams.
type V0ProjectFileStorageUploadParams struct {
	UploadFileName string `json:"upload_file_name"`
	UploadFileSize int    `json:"upload_file_size"`
	UserEnvKey     string `json:"user_env_key"`
}

// V0ProvProfileDocumentUpdateParams defines model for v0.ProvProfileDocumentUpdateParams.
type V0ProvProfileDocumentUpdateParams struct {
	IsExpose    *bool `json:"is_expose,omitempty"`
	IsProtected *bool `json:"is_protected,omitempty"`
	Processed   *bool `json:"processed,omitempty"`
}

// V0ProvisionProfileListResponseModel defines model for v0.ProvisionProfileListResponseModel.
type V0ProvisionProfileListResponseModel struct {
	Data *[]V0ProvisionProfileResponseItemModel `json:"data,omitempty"`

	// Paging pagination
	Paging *V0PagingResponseModel `json:"paging,omitempty"`
}

// V0ProvisionProfileResponseItemModel defines model for v0.ProvisionProfileResponseItemModel.
type V0ProvisionProfileResponseItemModel struct {
	DownloadUrl    *string `json:"download_url,omitempty"`
	IsExpose       *bool   `json:"is_expose,omitempty"`
	IsProtected    *bool   `json:"is_protected,omitempty"`
	Processed      *bool   `json:"processed,omitempty"`
	Slug           *string `json:"slug,omitempty"`
	UploadFileName *string `json:"upload_file_name,omitempty"`
	UploadFileSize *int    `json:"upload_file_size,omitempty"`
	UploadUrl      *string `json:"upload_url,omitempty"`
}

// V0ProvisionProfileResponseModel defines model for v0.ProvisionProfileResponseModel.
type V0ProvisionProfileResponseModel struct {
	Data *V0ProvisionProfileResponseItemModel `json:"data,omitempty"`
}

// V0ProvisionProfileUploadParams defines model for v0.ProvisionProfileUploadParams.
type V0ProvisionProfileUploadParams struct {
	UploadFileName string `json:"upload_file_name"`
	UploadFileSize int    `json:"upload_file_size"`
}

// V0ReleaseCreateAppStoreParams defines model for v0.ReleaseCreateAppStoreParams.
type V0ReleaseCreateAppStoreParams struct {
	// AutomaticTestflightUpload @Deprecated use `automatic_store_upload` instead. Indicates whether or not to upload every release candidate build automatically to TestFlight (default: `false`)
	AutomaticTestflightUpload *bool `json:"automatic_testflight_upload,omitempty"`

	// BundleId The bundle ID of the app to be released
	BundleId string `json:"bundle_id"`

	// Description An internal description of the release; it won't be propagated to the App Store (default: empty)
	Description *string `json:"description,omitempty"`

	// Name The name/version of the release (e.g. `1.2`)
	Name string `json:"name"`

	// ReleaseBranch The branch used for building the release candidate (default: empty)
	ReleaseBranch *string `json:"release_branch,omitempty"`

	// SlackWebhookUrl The Slack webhook URL to use for sending Slack notifications (default: empty)
	SlackWebhookUrl *string `json:"slack_webhook_url,omitempty"`

	// TeamsWebhookUrl The Teams webhook URL to use for sending MS Teams notifications (default: empty)
	TeamsWebhookUrl *string `json:"teams_webhook_url,omitempty"`

	// Workflow The workflow used for building the release candidate (default: empty)
	Workflow *string `json:"workflow,omitempty"`
}

// V0ReleaseCreateAppStoreRespModel defines model for v0.ReleaseCreateAppStoreRespModel.
type V0ReleaseCreateAppStoreRespModel struct {
	// BundleId The bundle ID of the app
	BundleId *string `json:"bundle_id,omitempty"`

	// Id The ID of the newly created release
	Id *string `json:"id,omitempty"`

	// Name The name/version of the release (e.g. `1.2`)
	Name *string `json:"name,omitempty"`

	// Platform The platform of the release (`ios`)
	Platform *string `json:"platform,omitempty"`

	// Status The status of the newly created release (`scheduled` or `in-progress`, depending on whether or not the release candidate settings were specified)
	Status *string `json:"status,omitempty"`
}

// V0ReleaseCreateGooglePlayParams defines model for v0.ReleaseCreateGooglePlayParams.
type V0ReleaseCreateGooglePlayParams struct {
	// AutomaticPlayConsoleUpload Indicates whether or not to upload every release candidate build automatically to the Google Play Console (default: `false`)
	AutomaticPlayConsoleUpload *bool `json:"automatic_play_console_upload,omitempty"`

	// Description An internal description of the release; it won't be propagated to the App Store (default: empty)
	Description *string `json:"description,omitempty"`

	// Name The name/version of the release (e.g. `1.2`)
	Name string `json:"name"`

	// PackageName The package name of the app to be released
	PackageName string `json:"package_name"`

	// ReleaseBranch The branch used for building the release candidate (default: empty)
	ReleaseBranch *string `json:"release_branch,omitempty"`

	// SlackWebhookUrl The Slack webhook URL to use for sending Slack notifications (default: empty)
	SlackWebhookUrl *string `json:"slack_webhook_url,omitempty"`

	// TeamsWebhookUrl The Teams webhook URL to use for sending MS Teams notifications (default: empty)
	TeamsWebhookUrl *string `json:"teams_webhook_url,omitempty"`

	// Workflow The workflow used for building the release candidate (default: empty)
	Workflow *string `json:"workflow,omitempty"`
}

// V0ReleaseCreateGooglePlayRespModel defines model for v0.ReleaseCreateGooglePlayRespModel.
type V0ReleaseCreateGooglePlayRespModel struct {
	// Id The ID of the newly created release
	Id *string `json:"id,omitempty"`

	// Name The name/version of the release (e.g. `1.2`)
	Name *string `json:"name,omitempty"`

	// PackageName The package name of the app
	PackageName *string `json:"package_name,omitempty"`

	// Platform The platform of the release (`android`)
	Platform *string `json:"platform,omitempty"`

	// Status The status of the newly created release (`scheduled` or `in-progress`, depending on whether or not the release candidate settings were specified)
	Status *string `json:"status,omitempty"`
}

// V0SSHKeyRespModel defines model for v0.SSHKeyRespModel.
type V0SSHKeyRespModel struct {
	Status *string `json:"status,omitempty"`
}

// V0SSHKeyUploadParams defines model for v0.SSHKeyUploadParams.
type V0SSHKeyUploadParams struct {
	// AuthSshPrivateKey The private part of the SSH key you would like to use
	AuthSshPrivateKey string `json:"auth_ssh_private_key"`

	// AuthSshPublicKey The public part of the SSH key you would like to use
	AuthSshPublicKey string `json:"auth_ssh_public_key"`

	// IsRegisterKeyIntoProviderService If it's set to true, the provided SSH key will be registered at the provider of the application
	IsRegisterKeyIntoProviderService *bool `json:"is_register_key_into_provider_service,omitempty"`
}

// V0TestDeviceListResponseModel defines model for v0.TestDeviceListResponseModel.
type V0TestDeviceListResponseModel struct {
	Data *[]V0TestDeviceResponseItemModel `json:"data,omitempty"`
}

// V0TestDeviceResponseItemModel defines model for v0.TestDeviceResponseItemModel.
type V0TestDeviceResponseItemModel struct {
	DeviceId   *string `json:"device_id,omitempty"`
	DeviceType *string `json:"device_type,omitempty"`
	Owner      *string `json:"owner,omitempty"`
}

// V0UserPlanDataModel defines model for v0.UserPlanDataModel.
type V0UserPlanDataModel struct {
	CurrentPlan    *V0PlanDataModel `json:"current_plan,omitempty"`
	PendingPlan    *V0PlanDataModel `json:"pending_plan,omitempty"`
	TrialExpiresAt *string          `json:"trial_expires_at,omitempty"`
}

// V0UserPlanRespModel defines model for v0.UserPlanRespModel.
type V0UserPlanRespModel struct {
	Data *V0UserPlanDataModel `json:"data,omitempty"`
}

// V0UserProfileDataModel defines model for v0.UserProfileDataModel.
type V0UserProfileDataModel struct {
	AvatarUrl                *string `json:"avatar_url,omitempty"`
	CreatedAt                *string `json:"created_at,omitempty"`
	DataId                   *int    `json:"data_id,omitempty"`
	Email                    *string `json:"email,omitempty"`
	HasUsedOrganizationTrial *bool   `json:"has_used_organization_trial,omitempty"`
	PaymentProcessor         *string `json:"payment_processor,omitempty"`
	Slug                     *string `json:"slug,omitempty"`
	UnconfirmedEmail         *string `json:"unconfirmed_email,omitempty"`
	Username                 *string `json:"username,omitempty"`
}

// V0UserProfileRespModel defines model for v0.UserProfileRespModel.
type V0UserProfileRespModel struct {
	Data *V0UserProfileDataModel `json:"data,omitempty"`
}

// V0WebhookDeliveryItemResponseModel defines model for v0.WebhookDeliveryItemResponseModel.
type V0WebhookDeliveryItemResponseModel struct {
	CreatedAt          *string      `json:"created_at,omitempty"`
	RequestHeaders     *string      `json:"request_headers,omitempty"`
	RequestPayload     *string      `json:"request_payload,omitempty"`
	RequestUrl         *string      `json:"request_url,omitempty"`
	ResponseBody       *NullsString `json:"response_body,omitempty"`
	ResponseHeaders    *NullsString `json:"response_headers,omitempty"`
	ResponseHttpStatus *NullsInt64  `json:"response_http_status,omitempty"`
	ResponseSeconds    *NullsInt64  `json:"response_seconds,omitempty"`
	Slug               *string      `json:"slug,omitempty"`
	UpdatedAt          *string      `json:"updated_at,omitempty"`
}

// V0WebhookDeliveryItemShowResponseModel defines model for v0.WebhookDeliveryItemShowResponseModel.
type V0WebhookDeliveryItemShowResponseModel struct {
	Data *V0WebhookDeliveryItemResponseModel `json:"data,omitempty"`
}

// V0WebhookRespModel defines model for v0.WebhookRespModel.
type V0WebhookRespModel struct {
	Status *string `json:"status,omitempty"`
}

// V0OrganizationUpdateMachineTypeResponseErrorsInner defines model for v0_OrganizationUpdateMachineTypeResponse_errors_inner.
type V0OrganizationUpdateMachineTypeResponseErrorsInner struct {
	// App The apps which had an error's identifiers in the following format "#{app.title} (#{app.slug})"
	App   *string `json:"app,omitempty"`
	Error *string `json:"error,omitempty"`
}

// WebsiteBitriseYMLLocation defines model for website.BitriseYMLLocation.
type WebsiteBitriseYMLLocation string

// AppListParams defines parameters for AppList.
type AppListParams struct {
	// SortBy Order of the applications: sort them based on when they were created or the time of their last build
	SortBy *AppListParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Next Slug of the first app in the response
	Next *string `form:"next,omitempty" json:"next,omitempty"`

	// Limit Max number of elements per page (default: 50)
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Title The title of the app
	Title *string `form:"title,omitempty" json:"title,omitempty"`

	// ProjectType The project type of the app (eg. 'ios', 'android')
	ProjectType *string `form:"project_type,omitempty" json:"project_type,omitempty"`
}

// AppListParamsSortBy defines parameters for AppList.
type AppListParamsSortBy string

// AndroidKeystoreFileListParams defines parameters for AndroidKeystoreFileList.
type AndroidKeystoreFileListParams struct {
	// Next Slug of the first android keystore file in the response
	Next *string `form:"next,omitempty" json:"next,omitempty"`

	// Limit Max number of build certificates per page is 50.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ArchivedBuildsListParams defines parameters for ArchivedBuildsList.
type ArchivedBuildsListParams struct {
	// After Listed builds should only be the ones which ran after the given date (Unix Timestamp)
	After int `form:"after" json:"after"`

	// Before Listed builds should only be the ones which ran before the given date (Unix Timestamp)
	Before int `form:"before" json:"before"`
}

// BuildCertificateListParams defines parameters for BuildCertificateList.
type BuildCertificateListParams struct {
	// Next Slug of the first build certificate in the response
	Next *string `form:"next,omitempty" json:"next,omitempty"`

	// Limit Max number of build certificates per page is 50.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// BuildListParams defines parameters for BuildList.
type BuildListParams struct {
	// SortBy Order of builds: sort them based on when they were created or the time when they were triggered
	SortBy *BuildListParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Branch The branch which was built
	Branch *string `form:"branch,omitempty" json:"branch,omitempty"`

	// Workflow The name of the workflow used for the build
	Workflow *string `form:"workflow,omitempty" json:"workflow,omitempty"`

	// CommitMessage The commit message of the build
	CommitMessage *string `form:"commit_message,omitempty" json:"commit_message,omitempty"`

	// TriggerEventType The event that triggered the build (push, pull-request, tag)
	TriggerEventType *string `form:"trigger_event_type,omitempty" json:"trigger_event_type,omitempty"`

	// PullRequestId The id of the pull request that triggered the build
	PullRequestId *int `form:"pull_request_id,omitempty" json:"pull_request_id,omitempty"`

	// BuildNumber The build number
	BuildNumber *int `form:"build_number,omitempty" json:"build_number,omitempty"`

	// After List builds run after a given date (Unix Timestamp)
	After *int `form:"after,omitempty" json:"after,omitempty"`

	// Before List builds run before a given date (Unix Timestamp)
	Before *int `form:"before,omitempty" json:"before,omitempty"`

	// Status The status of the build: not finished (0), successful (1), failed (2), aborted with failure (3), aborted with success (4)
	Status *int `form:"status,omitempty" json:"status,omitempty"`

	// IsPipelineBuild Whether the builds are part of a pipeline or not
	IsPipelineBuild *bool `form:"is_pipeline_build,omitempty" json:"is_pipeline_build,omitempty"`

	// Next Slug of the first build in the response
	Next *string `form:"next,omitempty" json:"next,omitempty"`

	// Limit Max number of elements per page (default: 50)
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// BuildListParamsSortBy defines parameters for BuildList.
type BuildListParamsSortBy string

// ArtifactListParams defines parameters for ArtifactList.
type ArtifactListParams struct {
	// Next Slug of the first build artifact in the response
	Next *string `form:"next,omitempty" json:"next,omitempty"`

	// Limit Max number of build artifacts per page is 50.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ArtifactShowParams defines parameters for ArtifactShow.
type ArtifactShowParams struct {
	// Download Setting this will result in a redirect to the artifact download location
	Download *int `form:"download,omitempty" json:"download,omitempty"`
}

// CacheListParams defines parameters for CacheList.
type CacheListParams struct {
	// Next Getting cache items created before the given parameter (RFC3339 time format, default: now)
	Next *string `form:"next,omitempty" json:"next,omitempty"`

	// Limit Max number of elements per page (default: 100)
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GenericProjectFileListParams defines parameters for GenericProjectFileList.
type GenericProjectFileListParams struct {
	// Next Slug of the first generic project file in the response
	Next *string `form:"next,omitempty" json:"next,omitempty"`

	// Limit Max number of build certificates per page is 50.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// LocalBuildListParams defines parameters for LocalBuildList.
type LocalBuildListParams struct {
	// After List local builds run after a given date (RFC3339 time format)
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before List local builds run before a given date (RFC3339 time format) - was called 'next' earlier
	Before *string `form:"before,omitempty" json:"before,omitempty"`

	// Limit Max number of elements per page (default: 10)
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// OutgoingWebhookListParams defines parameters for OutgoingWebhookList.
type OutgoingWebhookListParams struct {
	// Next Slug of the first webhook in the response
	Next *string `form:"next,omitempty" json:"next,omitempty"`

	// Limit Max number of elements per page (default: 50)
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// WebhookDeliveryItemListParams defines parameters for WebhookDeliveryItemList.
type WebhookDeliveryItemListParams struct {
	// Next Slug of the first delivery item in the response
	Next *string `form:"next,omitempty" json:"next,omitempty"`

	// Limit Max number of elements per page (default: 50)
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// PipelineListParams defines parameters for PipelineList.
type PipelineListParams struct {
	// After List pipelines/standalone builds run after a given date (RFC3339 time format)
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before List pipelines/standalone builds run before a given date (RFC3339 time format) - was called 'next' earlier
	Before *string `form:"before,omitempty" json:"before,omitempty"`

	// Branch The branch which was built
	Branch *string `form:"branch,omitempty" json:"branch,omitempty"`

	// BuildNumber The pipeline/standalone build number
	BuildNumber *int `form:"build_number,omitempty" json:"build_number,omitempty"`

	// BuildEnvironment The build environment of the listed builds (ci, local, all) - default: ci
	BuildEnvironment *string `form:"build_environment,omitempty" json:"build_environment,omitempty"`

	// CommitMessage The commit message of the pipeline/standalone build
	CommitMessage *string `form:"commit_message,omitempty" json:"commit_message,omitempty"`

	// Limit Max number of elements per page - default: 10
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Next List pipelines/standalone builds run before a given date (RFC3339 time format) - deprecated
	Next *string `form:"next,omitempty" json:"next,omitempty"`

	// Pipeline Name of the pipeline
	Pipeline *string `form:"pipeline,omitempty" json:"pipeline,omitempty"`

	// Status The status of the pipeline/standalone build: initializing, on_hold, running, succeeded, failed, aborted, succeeded_with_abort
	Status *string `form:"status,omitempty" json:"status,omitempty"`

	// TriggerEventType The event that triggered the pipeline/standalone build (push, pull-request, tag)
	TriggerEventType *string `form:"trigger_event_type,omitempty" json:"trigger_event_type,omitempty"`

	// Workflow The name of the workflow used for the pipeline/standalone build
	Workflow *string `form:"workflow,omitempty" json:"workflow,omitempty"`
}

// ProvisioningProfileListParams defines parameters for ProvisioningProfileList.
type ProvisioningProfileListParams struct {
	// Next Slug of the first provisioning profile in the response
	Next *string `form:"next,omitempty" json:"next,omitempty"`

	// Limit Max number of elements per page (default: 50)
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// AppRolesQueryParamsRoleName defines parameters for AppRolesQuery.
type AppRolesQueryParamsRoleName string

// AppRolesUpdateParamsRoleName defines parameters for AppRolesUpdate.
type AppRolesUpdateParamsRoleName string

// BuildListAllParams defines parameters for BuildListAll.
type BuildListAllParams struct {
	// OwnerSlug The slug of the owner of the app or apps
	OwnerSlug *string `form:"owner_slug,omitempty" json:"owner_slug,omitempty"`

	// IsOnHold Indicates whether the build has started yet (true: the build hasn't started)
	IsOnHold *bool `form:"is_on_hold,omitempty" json:"is_on_hold,omitempty"`

	// Status The status of the build: not finished (0), successful (1), failed (2), aborted with failure (3), aborted with success (4)
	Status *int `form:"status,omitempty" json:"status,omitempty"`

	// Next Slug of the first build in the response
	Next *string `form:"next,omitempty" json:"next,omitempty"`

	// Limit Max number of elements per page (default: 50)
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ActivityListParams defines parameters for ActivityList.
type ActivityListParams struct {
	// Next Slug of the first activity event in the response
	Next *string `form:"next,omitempty" json:"next,omitempty"`

	// Limit Max number of elements per page (default: 50)
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// AppListByOrganizationParams defines parameters for AppListByOrganization.
type AppListByOrganizationParams struct {
	// SortBy Order of applications: sort them based on when they were created or the time of their last build
	SortBy *AppListByOrganizationParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Next Slug of the first app in the response
	Next *string `form:"next,omitempty" json:"next,omitempty"`

	// Limit Max number of elements per page (default: 50)
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Title The title of the app
	Title *string `form:"title,omitempty" json:"title,omitempty"`

	// ProjectType The project type of the app (eg. 'ios', 'android')
	ProjectType *string `form:"project_type,omitempty" json:"project_type,omitempty"`
}

// AppListByOrganizationParamsSortBy defines parameters for AppListByOrganization.
type AppListByOrganizationParamsSortBy string

// PipelineListAllParams defines parameters for PipelineListAll.
type PipelineListAllParams struct {
	// OwnerSlug The slug of the owner of the app or apps
	OwnerSlug *string `form:"owner_slug,omitempty" json:"owner_slug,omitempty"`

	// Status The status of the pipelines/standalone build: initializing, on_hold, running, succeeded, failed, aborted, succeeded_with_abort
	Status *int `form:"status,omitempty" json:"status,omitempty"`

	// Next Getting pipelines/standalone builds before the given parameter (RFC3339 time format)
	Next *string `form:"next,omitempty" json:"next,omitempty"`

	// Limit Max number of elements per page (default: 10)
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// AppListByUserParams defines parameters for AppListByUser.
type AppListByUserParams struct {
	// SortBy Order of applications
	SortBy *AppListByUserParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Next Slug of the first app in the response
	Next *string `form:"next,omitempty" json:"next,omitempty"`

	// Limit Max number of elements per page (default: 50)
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Title The title of the app
	Title *string `form:"title,omitempty" json:"title,omitempty"`

	// ProjectType The project type of the app (eg. 'ios', 'android')
	ProjectType *string `form:"project_type,omitempty" json:"project_type,omitempty"`
}

// AppListByUserParamsSortBy defines parameters for AppListByUser.
type AppListByUserParamsSortBy string

// AppCreateJSONRequestBody defines body for AppCreate for application/json ContentType.
type AppCreateJSONRequestBody = V0AppUploadParams

// AppUpdateJSONRequestBody defines body for AppUpdate for application/json ContentType.
type AppUpdateJSONRequestBody = V0AppUpdateParams

// AndroidKeystoreFileCreateJSONRequestBody defines body for AndroidKeystoreFileCreate for application/json ContentType.
type AndroidKeystoreFileCreateJSONRequestBody = V0AndroidKeystoreFileUploadParams

// AppConfigCreateJSONRequestBody defines body for AppConfigCreate for application/json ContentType.
type AppConfigCreateJSONRequestBody = V0AppConfigRequestParam

// AppSetupBitriseYmlConfigUpdateJSONRequestBody defines body for AppSetupBitriseYmlConfigUpdate for application/json ContentType.
type AppSetupBitriseYmlConfigUpdateJSONRequestBody = V0BitriseYMLConfigUpdateParams

// BuildCertificateCreateJSONRequestBody defines body for BuildCertificateCreate for application/json ContentType.
type BuildCertificateCreateJSONRequestBody = V0BuildCertificateUploadParams

// BuildCertificateUpdateJSONRequestBody defines body for BuildCertificateUpdate for application/json ContentType.
type BuildCertificateUpdateJSONRequestBody = V0BuildCertificateUpdateParams

// BuildRequestUpdateJSONRequestBody defines body for BuildRequestUpdate for application/json ContentType.
type BuildRequestUpdateJSONRequestBody = V0BuildRequestUpdateParams

// BuildTriggerJSONRequestBody defines body for BuildTrigger for application/json ContentType.
type BuildTriggerJSONRequestBody = V0BuildTriggerParams

// BuildAbortJSONRequestBody defines body for BuildAbort for application/json ContentType.
type BuildAbortJSONRequestBody = V0BuildAbortParams

// ArtifactUpdateJSONRequestBody defines body for ArtifactUpdate for application/json ContentType.
type ArtifactUpdateJSONRequestBody = V0ArtifactUpdateParams

// AppFinishJSONRequestBody defines body for AppFinish for application/json ContentType.
type AppFinishJSONRequestBody = V0AppFinishParams

// GenericProjectFilesCreateJSONRequestBody defines body for GenericProjectFilesCreate for application/json ContentType.
type GenericProjectFilesCreateJSONRequestBody = V0ProjectFileStorageUploadParams

// GenericProjectFileUpdateJSONRequestBody defines body for GenericProjectFileUpdate for application/json ContentType.
type GenericProjectFileUpdateJSONRequestBody = V0ProjectFileStorageDocumentUpdateParams

// ProvisioningProfileCreateJSONRequestBody defines body for ProvisioningProfileCreate for application/json ContentType.
type ProvisioningProfileCreateJSONRequestBody = V0ProvisionProfileUploadParams

// ProvisioningProfileUpdateJSONRequestBody defines body for ProvisioningProfileUpdate for application/json ContentType.
type ProvisioningProfileUpdateJSONRequestBody = V0ProvProfileDocumentUpdateParams

// SshKeyCreateJSONRequestBody defines body for SshKeyCreate for application/json ContentType.
type SshKeyCreateJSONRequestBody = V0SSHKeyUploadParams

// ReleaseCreateAppStoreJSONRequestBody defines body for ReleaseCreateAppStore for application/json ContentType.
type ReleaseCreateAppStoreJSONRequestBody = V0ReleaseCreateAppStoreParams

// ReleaseCreateGooglePlayJSONRequestBody defines body for ReleaseCreateGooglePlay for application/json ContentType.
type ReleaseCreateGooglePlayJSONRequestBody = V0ReleaseCreateGooglePlayParams

// SecretUpsertJSONRequestBody defines body for SecretUpsert for application/json ContentType.
type SecretUpsertJSONRequestBody = V0AppSecretUpsertParams

// AppNotificationsJSONRequestBody defines body for AppNotifications for application/json ContentType.
type AppNotificationsJSONRequestBody = V0AppNotificationSettingsParams

// OrganizationMachineTypeUpdateJSONRequestBody defines body for OrganizationMachineTypeUpdate for application/json ContentType.
type OrganizationMachineTypeUpdateJSONRequestBody = V0OrganizationUpdateMachineTypeParams

// UserMachineTypeUpdateJSONRequestBody defines body for UserMachineTypeUpdate for application/json ContentType.
type UserMachineTypeUpdateJSONRequestBody = V0OrganizationUpdateMachineTypeParams

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AddonsList request
	AddonsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddonsShow request
	AddonsShow(ctx context.Context, addonId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppList request
	AppList(ctx context.Context, params *AppListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppCreateWithBody request with any body
	AppCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AppCreate(ctx context.Context, body AppCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppDelete request
	AppDelete(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppShow request
	AppShow(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppUpdateWithBody request with any body
	AppUpdateWithBody(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AppUpdate(ctx context.Context, appSlug string, body AppUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddonListByApp request
	AddonListByApp(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AndroidKeystoreFileList request
	AndroidKeystoreFileList(ctx context.Context, appSlug string, params *AndroidKeystoreFileListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AndroidKeystoreFileCreateWithBody request with any body
	AndroidKeystoreFileCreateWithBody(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AndroidKeystoreFileCreate(ctx context.Context, appSlug string, body AndroidKeystoreFileCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AndroidKeystoreFileDelete request
	AndroidKeystoreFileDelete(ctx context.Context, appSlug string, androidKeystoreFileSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AndroidKeystoreFileConfirm request
	AndroidKeystoreFileConfirm(ctx context.Context, appSlug string, androidKeystoreFileSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchivedBuildsList request
	ArchivedBuildsList(ctx context.Context, appSlug string, params *ArchivedBuildsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppConfigDatastoreShow request
	AppConfigDatastoreShow(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppConfigCreateWithBody request with any body
	AppConfigCreateWithBody(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AppConfigCreate(ctx context.Context, appSlug string, body AppConfigCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppSetupBitriseYmlConfigGet request
	AppSetupBitriseYmlConfigGet(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppSetupBitriseYmlConfigUpdateWithBody request with any body
	AppSetupBitriseYmlConfigUpdateWithBody(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AppSetupBitriseYmlConfigUpdate(ctx context.Context, appSlug string, body AppSetupBitriseYmlConfigUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BranchList request
	BranchList(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BuildCertificateList request
	BuildCertificateList(ctx context.Context, appSlug string, params *BuildCertificateListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BuildCertificateCreateWithBody request with any body
	BuildCertificateCreateWithBody(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BuildCertificateCreate(ctx context.Context, appSlug string, body BuildCertificateCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BuildCertificateDelete request
	BuildCertificateDelete(ctx context.Context, appSlug string, buildCertificateSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BuildCertificateShow request
	BuildCertificateShow(ctx context.Context, appSlug string, buildCertificateSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BuildCertificateUpdateWithBody request with any body
	BuildCertificateUpdateWithBody(ctx context.Context, appSlug string, buildCertificateSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BuildCertificateUpdate(ctx context.Context, appSlug string, buildCertificateSlug string, body BuildCertificateUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BuildCertificateConfirm request
	BuildCertificateConfirm(ctx context.Context, appSlug string, buildCertificateSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BuildRequestList request
	BuildRequestList(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BuildRequestUpdateWithBody request with any body
	BuildRequestUpdateWithBody(ctx context.Context, appSlug string, buildRequestSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BuildRequestUpdate(ctx context.Context, appSlug string, buildRequestSlug string, body BuildRequestUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BuildWorkflowList request
	BuildWorkflowList(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BuildList request
	BuildList(ctx context.Context, appSlug string, params *BuildListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BuildTriggerWithBody request with any body
	BuildTriggerWithBody(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BuildTrigger(ctx context.Context, appSlug string, body BuildTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BuildShow request
	BuildShow(ctx context.Context, appSlug string, buildSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BuildAbortWithBody request with any body
	BuildAbortWithBody(ctx context.Context, appSlug string, buildSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BuildAbort(ctx context.Context, appSlug string, buildSlug string, body BuildAbortJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArtifactList request
	ArtifactList(ctx context.Context, appSlug string, buildSlug string, params *ArtifactListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArtifactDelete request
	ArtifactDelete(ctx context.Context, appSlug string, buildSlug string, artifactSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArtifactShow request
	ArtifactShow(ctx context.Context, appSlug string, buildSlug string, artifactSlug string, params *ArtifactShowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArtifactUpdateWithBody request with any body
	ArtifactUpdateWithBody(ctx context.Context, appSlug string, buildSlug string, artifactSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArtifactUpdate(ctx context.Context, appSlug string, buildSlug string, artifactSlug string, body ArtifactUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BuildBitriseYmlShow request
	BuildBitriseYmlShow(ctx context.Context, appSlug string, buildSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BuildLog request
	BuildLog(ctx context.Context, appSlug string, buildSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CacheItemDeleteAll request
	CacheItemDeleteAll(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CacheList request
	CacheList(ctx context.Context, appSlug string, params *CacheListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CacheItemDelete request
	CacheItemDelete(ctx context.Context, appSlug string, cacheItemId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CacheItemDownload request
	CacheItemDownload(ctx context.Context, appSlug string, cacheItemId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppFinishWithBody request with any body
	AppFinishWithBody(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AppFinish(ctx context.Context, appSlug string, body AppFinishJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenericProjectFileList request
	GenericProjectFileList(ctx context.Context, appSlug string, params *GenericProjectFileListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenericProjectFilesCreateWithBody request with any body
	GenericProjectFilesCreateWithBody(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenericProjectFilesCreate(ctx context.Context, appSlug string, body GenericProjectFilesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenericProjectFileDelete request
	GenericProjectFileDelete(ctx context.Context, appSlug string, genericProjectFileSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenericProjectFileShow request
	GenericProjectFileShow(ctx context.Context, appSlug string, genericProjectFileSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenericProjectFileUpdateWithBody request with any body
	GenericProjectFileUpdateWithBody(ctx context.Context, appSlug string, genericProjectFileSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenericProjectFileUpdate(ctx context.Context, appSlug string, genericProjectFileSlug string, body GenericProjectFileUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenericProjectFileConfirm request
	GenericProjectFileConfirm(ctx context.Context, appSlug string, genericProjectFileSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LocalBuildList request
	LocalBuildList(ctx context.Context, appSlug string, params *LocalBuildListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OutgoingWebhookList request
	OutgoingWebhookList(ctx context.Context, appSlug string, params *OutgoingWebhookListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OutgoingWebhookCreateWithBody request with any body
	OutgoingWebhookCreateWithBody(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OutgoingWebhookDelete request
	OutgoingWebhookDelete(ctx context.Context, appSlug string, appWebhookSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OutgoingWebhookUpdateWithBody request with any body
	OutgoingWebhookUpdateWithBody(ctx context.Context, appSlug string, appWebhookSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhookDeliveryItemList request
	WebhookDeliveryItemList(ctx context.Context, appSlug string, appWebhookSlug string, params *WebhookDeliveryItemListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhookDeliveryItemShow request
	WebhookDeliveryItemShow(ctx context.Context, appSlug string, appWebhookSlug string, webhookDeliveryItemSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhookDeliveryItemRedeliver request
	WebhookDeliveryItemRedeliver(ctx context.Context, appSlug string, appWebhookSlug string, webhookDeliveryItemSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PipelineList request
	PipelineList(ctx context.Context, appSlug string, params *PipelineListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PipelineShow request
	PipelineShow(ctx context.Context, appSlug string, pipelineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PipelineAbortWithBody request with any body
	PipelineAbortWithBody(ctx context.Context, appSlug string, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PipelineRebuildWithBody request with any body
	PipelineRebuildWithBody(ctx context.Context, appSlug string, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProvisioningProfileList request
	ProvisioningProfileList(ctx context.Context, appSlug string, params *ProvisioningProfileListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProvisioningProfileCreateWithBody request with any body
	ProvisioningProfileCreateWithBody(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProvisioningProfileCreate(ctx context.Context, appSlug string, body ProvisioningProfileCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProvisioningProfileDelete request
	ProvisioningProfileDelete(ctx context.Context, appSlug string, provisioningProfileSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProvisioningProfileShow request
	ProvisioningProfileShow(ctx context.Context, appSlug string, provisioningProfileSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProvisioningProfileUpdateWithBody request with any body
	ProvisioningProfileUpdateWithBody(ctx context.Context, appSlug string, provisioningProfileSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProvisioningProfileUpdate(ctx context.Context, appSlug string, provisioningProfileSlug string, body ProvisioningProfileUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProvisioningProfileConfirm request
	ProvisioningProfileConfirm(ctx context.Context, appSlug string, provisioningProfileSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SshKeyCreateWithBody request with any body
	SshKeyCreateWithBody(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SshKeyCreate(ctx context.Context, appSlug string, body SshKeyCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppWebhookCreate request
	AppWebhookCreate(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReleaseCreateAppStoreWithBody request with any body
	ReleaseCreateAppStoreWithBody(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReleaseCreateAppStore(ctx context.Context, appSlug string, body ReleaseCreateAppStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReleaseCreateGooglePlayWithBody request with any body
	ReleaseCreateGooglePlayWithBody(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReleaseCreateGooglePlay(ctx context.Context, appSlug string, body ReleaseCreateGooglePlayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppRolesQuery request
	AppRolesQuery(ctx context.Context, appSlug string, roleName AppRolesQueryParamsRoleName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppRolesUpdateWithBody request with any body
	AppRolesUpdateWithBody(ctx context.Context, appSlug string, roleName AppRolesUpdateParamsRoleName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SecretList request
	SecretList(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SecretDelete request
	SecretDelete(ctx context.Context, appSlug string, secretName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SecretUpsertWithBody request with any body
	SecretUpsertWithBody(ctx context.Context, appSlug string, secretName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SecretUpsert(ctx context.Context, appSlug string, secretName string, body SecretUpsertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SecretValueGet request
	SecretValueGet(ctx context.Context, appSlug string, secretName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestDeviceList request
	TestDeviceList(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppNotificationsWithBody request with any body
	AppNotificationsWithBody(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AppNotifications(ctx context.Context, appSlug string, body AppNotificationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BuildListAll request
	BuildListAll(ctx context.Context, params *BuildListAllParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserProfile request
	UserProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivityList request
	ActivityList(ctx context.Context, params *ActivityListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserPlan request
	UserPlan(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgList request
	OrgList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgShow request
	OrgShow(ctx context.Context, orgSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppListByOrganization request
	AppListByOrganization(ctx context.Context, orgSlug string, params *AppListByOrganizationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganizationMachineTypeUpdateWithBody request with any body
	OrganizationMachineTypeUpdateWithBody(ctx context.Context, orgSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrganizationMachineTypeUpdate(ctx context.Context, orgSlug string, body OrganizationMachineTypeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganzationGroupsList request
	OrganzationGroupsList(ctx context.Context, orgSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddonListByOrganization request
	AddonListByOrganization(ctx context.Context, organizationSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PipelineListAll request
	PipelineListAll(ctx context.Context, params *PipelineListAllParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserMachineTypeUpdateWithBody request with any body
	UserMachineTypeUpdateWithBody(ctx context.Context, userSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserMachineTypeUpdate(ctx context.Context, userSlug string, body UserMachineTypeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserShow request
	UserShow(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddonListByUser request
	AddonListByUser(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppleApiCredentialList request
	AppleApiCredentialList(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppListByUser request
	AppListByUser(ctx context.Context, userSlug string, params *AppListByUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AddonsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddonsListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddonsShow(ctx context.Context, addonId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddonsShowRequest(c.Server, addonId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppList(ctx context.Context, params *AppListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppCreate(ctx context.Context, body AppCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppDelete(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppDeleteRequest(c.Server, appSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppShow(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppShowRequest(c.Server, appSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppUpdateWithBody(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppUpdateRequestWithBody(c.Server, appSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppUpdate(ctx context.Context, appSlug string, body AppUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppUpdateRequest(c.Server, appSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddonListByApp(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddonListByAppRequest(c.Server, appSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AndroidKeystoreFileList(ctx context.Context, appSlug string, params *AndroidKeystoreFileListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAndroidKeystoreFileListRequest(c.Server, appSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AndroidKeystoreFileCreateWithBody(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAndroidKeystoreFileCreateRequestWithBody(c.Server, appSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AndroidKeystoreFileCreate(ctx context.Context, appSlug string, body AndroidKeystoreFileCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAndroidKeystoreFileCreateRequest(c.Server, appSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AndroidKeystoreFileDelete(ctx context.Context, appSlug string, androidKeystoreFileSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAndroidKeystoreFileDeleteRequest(c.Server, appSlug, androidKeystoreFileSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AndroidKeystoreFileConfirm(ctx context.Context, appSlug string, androidKeystoreFileSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAndroidKeystoreFileConfirmRequest(c.Server, appSlug, androidKeystoreFileSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchivedBuildsList(ctx context.Context, appSlug string, params *ArchivedBuildsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchivedBuildsListRequest(c.Server, appSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppConfigDatastoreShow(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppConfigDatastoreShowRequest(c.Server, appSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppConfigCreateWithBody(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppConfigCreateRequestWithBody(c.Server, appSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppConfigCreate(ctx context.Context, appSlug string, body AppConfigCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppConfigCreateRequest(c.Server, appSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppSetupBitriseYmlConfigGet(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppSetupBitriseYmlConfigGetRequest(c.Server, appSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppSetupBitriseYmlConfigUpdateWithBody(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppSetupBitriseYmlConfigUpdateRequestWithBody(c.Server, appSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppSetupBitriseYmlConfigUpdate(ctx context.Context, appSlug string, body AppSetupBitriseYmlConfigUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppSetupBitriseYmlConfigUpdateRequest(c.Server, appSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BranchList(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBranchListRequest(c.Server, appSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BuildCertificateList(ctx context.Context, appSlug string, params *BuildCertificateListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBuildCertificateListRequest(c.Server, appSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BuildCertificateCreateWithBody(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBuildCertificateCreateRequestWithBody(c.Server, appSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BuildCertificateCreate(ctx context.Context, appSlug string, body BuildCertificateCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBuildCertificateCreateRequest(c.Server, appSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BuildCertificateDelete(ctx context.Context, appSlug string, buildCertificateSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBuildCertificateDeleteRequest(c.Server, appSlug, buildCertificateSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BuildCertificateShow(ctx context.Context, appSlug string, buildCertificateSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBuildCertificateShowRequest(c.Server, appSlug, buildCertificateSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BuildCertificateUpdateWithBody(ctx context.Context, appSlug string, buildCertificateSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBuildCertificateUpdateRequestWithBody(c.Server, appSlug, buildCertificateSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BuildCertificateUpdate(ctx context.Context, appSlug string, buildCertificateSlug string, body BuildCertificateUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBuildCertificateUpdateRequest(c.Server, appSlug, buildCertificateSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BuildCertificateConfirm(ctx context.Context, appSlug string, buildCertificateSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBuildCertificateConfirmRequest(c.Server, appSlug, buildCertificateSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BuildRequestList(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBuildRequestListRequest(c.Server, appSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BuildRequestUpdateWithBody(ctx context.Context, appSlug string, buildRequestSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBuildRequestUpdateRequestWithBody(c.Server, appSlug, buildRequestSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BuildRequestUpdate(ctx context.Context, appSlug string, buildRequestSlug string, body BuildRequestUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBuildRequestUpdateRequest(c.Server, appSlug, buildRequestSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BuildWorkflowList(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBuildWorkflowListRequest(c.Server, appSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BuildList(ctx context.Context, appSlug string, params *BuildListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBuildListRequest(c.Server, appSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BuildTriggerWithBody(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBuildTriggerRequestWithBody(c.Server, appSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BuildTrigger(ctx context.Context, appSlug string, body BuildTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBuildTriggerRequest(c.Server, appSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BuildShow(ctx context.Context, appSlug string, buildSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBuildShowRequest(c.Server, appSlug, buildSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BuildAbortWithBody(ctx context.Context, appSlug string, buildSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBuildAbortRequestWithBody(c.Server, appSlug, buildSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BuildAbort(ctx context.Context, appSlug string, buildSlug string, body BuildAbortJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBuildAbortRequest(c.Server, appSlug, buildSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactList(ctx context.Context, appSlug string, buildSlug string, params *ArtifactListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactListRequest(c.Server, appSlug, buildSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactDelete(ctx context.Context, appSlug string, buildSlug string, artifactSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactDeleteRequest(c.Server, appSlug, buildSlug, artifactSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactShow(ctx context.Context, appSlug string, buildSlug string, artifactSlug string, params *ArtifactShowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactShowRequest(c.Server, appSlug, buildSlug, artifactSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactUpdateWithBody(ctx context.Context, appSlug string, buildSlug string, artifactSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactUpdateRequestWithBody(c.Server, appSlug, buildSlug, artifactSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactUpdate(ctx context.Context, appSlug string, buildSlug string, artifactSlug string, body ArtifactUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactUpdateRequest(c.Server, appSlug, buildSlug, artifactSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BuildBitriseYmlShow(ctx context.Context, appSlug string, buildSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBuildBitriseYmlShowRequest(c.Server, appSlug, buildSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BuildLog(ctx context.Context, appSlug string, buildSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBuildLogRequest(c.Server, appSlug, buildSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CacheItemDeleteAll(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCacheItemDeleteAllRequest(c.Server, appSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CacheList(ctx context.Context, appSlug string, params *CacheListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCacheListRequest(c.Server, appSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CacheItemDelete(ctx context.Context, appSlug string, cacheItemId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCacheItemDeleteRequest(c.Server, appSlug, cacheItemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CacheItemDownload(ctx context.Context, appSlug string, cacheItemId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCacheItemDownloadRequest(c.Server, appSlug, cacheItemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppFinishWithBody(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppFinishRequestWithBody(c.Server, appSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppFinish(ctx context.Context, appSlug string, body AppFinishJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppFinishRequest(c.Server, appSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenericProjectFileList(ctx context.Context, appSlug string, params *GenericProjectFileListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenericProjectFileListRequest(c.Server, appSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenericProjectFilesCreateWithBody(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenericProjectFilesCreateRequestWithBody(c.Server, appSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenericProjectFilesCreate(ctx context.Context, appSlug string, body GenericProjectFilesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenericProjectFilesCreateRequest(c.Server, appSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenericProjectFileDelete(ctx context.Context, appSlug string, genericProjectFileSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenericProjectFileDeleteRequest(c.Server, appSlug, genericProjectFileSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenericProjectFileShow(ctx context.Context, appSlug string, genericProjectFileSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenericProjectFileShowRequest(c.Server, appSlug, genericProjectFileSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenericProjectFileUpdateWithBody(ctx context.Context, appSlug string, genericProjectFileSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenericProjectFileUpdateRequestWithBody(c.Server, appSlug, genericProjectFileSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenericProjectFileUpdate(ctx context.Context, appSlug string, genericProjectFileSlug string, body GenericProjectFileUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenericProjectFileUpdateRequest(c.Server, appSlug, genericProjectFileSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenericProjectFileConfirm(ctx context.Context, appSlug string, genericProjectFileSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenericProjectFileConfirmRequest(c.Server, appSlug, genericProjectFileSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LocalBuildList(ctx context.Context, appSlug string, params *LocalBuildListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLocalBuildListRequest(c.Server, appSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OutgoingWebhookList(ctx context.Context, appSlug string, params *OutgoingWebhookListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOutgoingWebhookListRequest(c.Server, appSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OutgoingWebhookCreateWithBody(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOutgoingWebhookCreateRequestWithBody(c.Server, appSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OutgoingWebhookDelete(ctx context.Context, appSlug string, appWebhookSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOutgoingWebhookDeleteRequest(c.Server, appSlug, appWebhookSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OutgoingWebhookUpdateWithBody(ctx context.Context, appSlug string, appWebhookSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOutgoingWebhookUpdateRequestWithBody(c.Server, appSlug, appWebhookSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhookDeliveryItemList(ctx context.Context, appSlug string, appWebhookSlug string, params *WebhookDeliveryItemListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhookDeliveryItemListRequest(c.Server, appSlug, appWebhookSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhookDeliveryItemShow(ctx context.Context, appSlug string, appWebhookSlug string, webhookDeliveryItemSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhookDeliveryItemShowRequest(c.Server, appSlug, appWebhookSlug, webhookDeliveryItemSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhookDeliveryItemRedeliver(ctx context.Context, appSlug string, appWebhookSlug string, webhookDeliveryItemSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhookDeliveryItemRedeliverRequest(c.Server, appSlug, appWebhookSlug, webhookDeliveryItemSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PipelineList(ctx context.Context, appSlug string, params *PipelineListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPipelineListRequest(c.Server, appSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PipelineShow(ctx context.Context, appSlug string, pipelineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPipelineShowRequest(c.Server, appSlug, pipelineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PipelineAbortWithBody(ctx context.Context, appSlug string, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPipelineAbortRequestWithBody(c.Server, appSlug, pipelineId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PipelineRebuildWithBody(ctx context.Context, appSlug string, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPipelineRebuildRequestWithBody(c.Server, appSlug, pipelineId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProvisioningProfileList(ctx context.Context, appSlug string, params *ProvisioningProfileListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProvisioningProfileListRequest(c.Server, appSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProvisioningProfileCreateWithBody(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProvisioningProfileCreateRequestWithBody(c.Server, appSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProvisioningProfileCreate(ctx context.Context, appSlug string, body ProvisioningProfileCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProvisioningProfileCreateRequest(c.Server, appSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProvisioningProfileDelete(ctx context.Context, appSlug string, provisioningProfileSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProvisioningProfileDeleteRequest(c.Server, appSlug, provisioningProfileSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProvisioningProfileShow(ctx context.Context, appSlug string, provisioningProfileSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProvisioningProfileShowRequest(c.Server, appSlug, provisioningProfileSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProvisioningProfileUpdateWithBody(ctx context.Context, appSlug string, provisioningProfileSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProvisioningProfileUpdateRequestWithBody(c.Server, appSlug, provisioningProfileSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProvisioningProfileUpdate(ctx context.Context, appSlug string, provisioningProfileSlug string, body ProvisioningProfileUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProvisioningProfileUpdateRequest(c.Server, appSlug, provisioningProfileSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProvisioningProfileConfirm(ctx context.Context, appSlug string, provisioningProfileSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProvisioningProfileConfirmRequest(c.Server, appSlug, provisioningProfileSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SshKeyCreateWithBody(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSshKeyCreateRequestWithBody(c.Server, appSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SshKeyCreate(ctx context.Context, appSlug string, body SshKeyCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSshKeyCreateRequest(c.Server, appSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppWebhookCreate(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppWebhookCreateRequest(c.Server, appSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReleaseCreateAppStoreWithBody(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReleaseCreateAppStoreRequestWithBody(c.Server, appSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReleaseCreateAppStore(ctx context.Context, appSlug string, body ReleaseCreateAppStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReleaseCreateAppStoreRequest(c.Server, appSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReleaseCreateGooglePlayWithBody(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReleaseCreateGooglePlayRequestWithBody(c.Server, appSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReleaseCreateGooglePlay(ctx context.Context, appSlug string, body ReleaseCreateGooglePlayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReleaseCreateGooglePlayRequest(c.Server, appSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppRolesQuery(ctx context.Context, appSlug string, roleName AppRolesQueryParamsRoleName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppRolesQueryRequest(c.Server, appSlug, roleName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppRolesUpdateWithBody(ctx context.Context, appSlug string, roleName AppRolesUpdateParamsRoleName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppRolesUpdateRequestWithBody(c.Server, appSlug, roleName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SecretList(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSecretListRequest(c.Server, appSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SecretDelete(ctx context.Context, appSlug string, secretName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSecretDeleteRequest(c.Server, appSlug, secretName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SecretUpsertWithBody(ctx context.Context, appSlug string, secretName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSecretUpsertRequestWithBody(c.Server, appSlug, secretName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SecretUpsert(ctx context.Context, appSlug string, secretName string, body SecretUpsertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSecretUpsertRequest(c.Server, appSlug, secretName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SecretValueGet(ctx context.Context, appSlug string, secretName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSecretValueGetRequest(c.Server, appSlug, secretName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestDeviceList(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestDeviceListRequest(c.Server, appSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppNotificationsWithBody(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppNotificationsRequestWithBody(c.Server, appSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppNotifications(ctx context.Context, appSlug string, body AppNotificationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppNotificationsRequest(c.Server, appSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BuildListAll(ctx context.Context, params *BuildListAllParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBuildListAllRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserProfileRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivityList(ctx context.Context, params *ActivityListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivityListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserPlan(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserPlanRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgShow(ctx context.Context, orgSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgShowRequest(c.Server, orgSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppListByOrganization(ctx context.Context, orgSlug string, params *AppListByOrganizationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppListByOrganizationRequest(c.Server, orgSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationMachineTypeUpdateWithBody(ctx context.Context, orgSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationMachineTypeUpdateRequestWithBody(c.Server, orgSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationMachineTypeUpdate(ctx context.Context, orgSlug string, body OrganizationMachineTypeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationMachineTypeUpdateRequest(c.Server, orgSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganzationGroupsList(ctx context.Context, orgSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganzationGroupsListRequest(c.Server, orgSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddonListByOrganization(ctx context.Context, organizationSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddonListByOrganizationRequest(c.Server, organizationSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PipelineListAll(ctx context.Context, params *PipelineListAllParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPipelineListAllRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserMachineTypeUpdateWithBody(ctx context.Context, userSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserMachineTypeUpdateRequestWithBody(c.Server, userSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserMachineTypeUpdate(ctx context.Context, userSlug string, body UserMachineTypeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserMachineTypeUpdateRequest(c.Server, userSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserShow(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserShowRequest(c.Server, userSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddonListByUser(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddonListByUserRequest(c.Server, userSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppleApiCredentialList(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppleApiCredentialListRequest(c.Server, userSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppListByUser(ctx context.Context, userSlug string, params *AppListByUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppListByUserRequest(c.Server, userSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAddonsListRequest generates requests for AddonsList
func NewAddonsListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddonsShowRequest generates requests for AddonsShow
func NewAddonsShowRequest(server string, addonId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "addon-id", runtime.ParamLocationPath, addonId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppListRequest generates requests for AppList
func NewAppListRequest(server string, params *AppListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Title != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_type", runtime.ParamLocationQuery, *params.ProjectType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppCreateRequest calls the generic AppCreate builder with application/json body
func NewAppCreateRequest(server string, body AppCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewAppCreateRequestWithBody generates requests for AppCreate with any type of body
func NewAppCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/register")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAppDeleteRequest generates requests for AppDelete
func NewAppDeleteRequest(server string, appSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppShowRequest generates requests for AppShow
func NewAppShowRequest(server string, appSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppUpdateRequest calls the generic AppUpdate builder with application/json body
func NewAppUpdateRequest(server string, appSlug string, body AppUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppUpdateRequestWithBody(server, appSlug, "application/json", bodyReader)
}

// NewAppUpdateRequestWithBody generates requests for AppUpdate with any type of body
func NewAppUpdateRequestWithBody(server string, appSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddonListByAppRequest generates requests for AddonListByApp
func NewAddonListByAppRequest(server string, appSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/addons", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAndroidKeystoreFileListRequest generates requests for AndroidKeystoreFileList
func NewAndroidKeystoreFileListRequest(server string, appSlug string, params *AndroidKeystoreFileListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/android-keystore-files", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAndroidKeystoreFileCreateRequest calls the generic AndroidKeystoreFileCreate builder with application/json body
func NewAndroidKeystoreFileCreateRequest(server string, appSlug string, body AndroidKeystoreFileCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAndroidKeystoreFileCreateRequestWithBody(server, appSlug, "application/json", bodyReader)
}

// NewAndroidKeystoreFileCreateRequestWithBody generates requests for AndroidKeystoreFileCreate with any type of body
func NewAndroidKeystoreFileCreateRequestWithBody(server string, appSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/android-keystore-files", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAndroidKeystoreFileDeleteRequest generates requests for AndroidKeystoreFileDelete
func NewAndroidKeystoreFileDeleteRequest(server string, appSlug string, androidKeystoreFileSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "android-keystore-file-slug", runtime.ParamLocationPath, androidKeystoreFileSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/android-keystore-files/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAndroidKeystoreFileConfirmRequest generates requests for AndroidKeystoreFileConfirm
func NewAndroidKeystoreFileConfirmRequest(server string, appSlug string, androidKeystoreFileSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "android-keystore-file-slug", runtime.ParamLocationPath, androidKeystoreFileSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/android-keystore-files/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArchivedBuildsListRequest generates requests for ArchivedBuildsList
func NewArchivedBuildsListRequest(server string, appSlug string, params *ArchivedBuildsListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/archived-builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppConfigDatastoreShowRequest generates requests for AppConfigDatastoreShow
func NewAppConfigDatastoreShowRequest(server string, appSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/bitrise.yml", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppConfigCreateRequest calls the generic AppConfigCreate builder with application/json body
func NewAppConfigCreateRequest(server string, appSlug string, body AppConfigCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppConfigCreateRequestWithBody(server, appSlug, "application/json", bodyReader)
}

// NewAppConfigCreateRequestWithBody generates requests for AppConfigCreate with any type of body
func NewAppConfigCreateRequestWithBody(server string, appSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/bitrise.yml", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAppSetupBitriseYmlConfigGetRequest generates requests for AppSetupBitriseYmlConfigGet
func NewAppSetupBitriseYmlConfigGetRequest(server string, appSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/bitrise.yml/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppSetupBitriseYmlConfigUpdateRequest calls the generic AppSetupBitriseYmlConfigUpdate builder with application/json body
func NewAppSetupBitriseYmlConfigUpdateRequest(server string, appSlug string, body AppSetupBitriseYmlConfigUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppSetupBitriseYmlConfigUpdateRequestWithBody(server, appSlug, "application/json", bodyReader)
}

// NewAppSetupBitriseYmlConfigUpdateRequestWithBody generates requests for AppSetupBitriseYmlConfigUpdate with any type of body
func NewAppSetupBitriseYmlConfigUpdateRequestWithBody(server string, appSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/bitrise.yml/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBranchListRequest generates requests for BranchList
func NewBranchListRequest(server string, appSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/branches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildCertificateListRequest generates requests for BuildCertificateList
func NewBuildCertificateListRequest(server string, appSlug string, params *BuildCertificateListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/build-certificates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildCertificateCreateRequest calls the generic BuildCertificateCreate builder with application/json body
func NewBuildCertificateCreateRequest(server string, appSlug string, body BuildCertificateCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBuildCertificateCreateRequestWithBody(server, appSlug, "application/json", bodyReader)
}

// NewBuildCertificateCreateRequestWithBody generates requests for BuildCertificateCreate with any type of body
func NewBuildCertificateCreateRequestWithBody(server string, appSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/build-certificates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBuildCertificateDeleteRequest generates requests for BuildCertificateDelete
func NewBuildCertificateDeleteRequest(server string, appSlug string, buildCertificateSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "build-certificate-slug", runtime.ParamLocationPath, buildCertificateSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/build-certificates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildCertificateShowRequest generates requests for BuildCertificateShow
func NewBuildCertificateShowRequest(server string, appSlug string, buildCertificateSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "build-certificate-slug", runtime.ParamLocationPath, buildCertificateSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/build-certificates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildCertificateUpdateRequest calls the generic BuildCertificateUpdate builder with application/json body
func NewBuildCertificateUpdateRequest(server string, appSlug string, buildCertificateSlug string, body BuildCertificateUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBuildCertificateUpdateRequestWithBody(server, appSlug, buildCertificateSlug, "application/json", bodyReader)
}

// NewBuildCertificateUpdateRequestWithBody generates requests for BuildCertificateUpdate with any type of body
func NewBuildCertificateUpdateRequestWithBody(server string, appSlug string, buildCertificateSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "build-certificate-slug", runtime.ParamLocationPath, buildCertificateSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/build-certificates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBuildCertificateConfirmRequest generates requests for BuildCertificateConfirm
func NewBuildCertificateConfirmRequest(server string, appSlug string, buildCertificateSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "build-certificate-slug", runtime.ParamLocationPath, buildCertificateSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/build-certificates/%s/uploaded", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildRequestListRequest generates requests for BuildRequestList
func NewBuildRequestListRequest(server string, appSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/build-requests", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildRequestUpdateRequest calls the generic BuildRequestUpdate builder with application/json body
func NewBuildRequestUpdateRequest(server string, appSlug string, buildRequestSlug string, body BuildRequestUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBuildRequestUpdateRequestWithBody(server, appSlug, buildRequestSlug, "application/json", bodyReader)
}

// NewBuildRequestUpdateRequestWithBody generates requests for BuildRequestUpdate with any type of body
func NewBuildRequestUpdateRequestWithBody(server string, appSlug string, buildRequestSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "build-request-slug", runtime.ParamLocationPath, buildRequestSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/build-requests/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBuildWorkflowListRequest generates requests for BuildWorkflowList
func NewBuildWorkflowListRequest(server string, appSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/build-workflows", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildListRequest generates requests for BuildList
func NewBuildListRequest(server string, appSlug string, params *BuildListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Branch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "branch", runtime.ParamLocationQuery, *params.Branch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Workflow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workflow", runtime.ParamLocationQuery, *params.Workflow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CommitMessage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "commit_message", runtime.ParamLocationQuery, *params.CommitMessage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TriggerEventType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trigger_event_type", runtime.ParamLocationQuery, *params.TriggerEventType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PullRequestId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pull_request_id", runtime.ParamLocationQuery, *params.PullRequestId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BuildNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "build_number", runtime.ParamLocationQuery, *params.BuildNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsPipelineBuild != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_pipeline_build", runtime.ParamLocationQuery, *params.IsPipelineBuild); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildTriggerRequest calls the generic BuildTrigger builder with application/json body
func NewBuildTriggerRequest(server string, appSlug string, body BuildTriggerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBuildTriggerRequestWithBody(server, appSlug, "application/json", bodyReader)
}

// NewBuildTriggerRequestWithBody generates requests for BuildTrigger with any type of body
func NewBuildTriggerRequestWithBody(server string, appSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBuildShowRequest generates requests for BuildShow
func NewBuildShowRequest(server string, appSlug string, buildSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "build-slug", runtime.ParamLocationPath, buildSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/builds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildAbortRequest calls the generic BuildAbort builder with application/json body
func NewBuildAbortRequest(server string, appSlug string, buildSlug string, body BuildAbortJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBuildAbortRequestWithBody(server, appSlug, buildSlug, "application/json", bodyReader)
}

// NewBuildAbortRequestWithBody generates requests for BuildAbort with any type of body
func NewBuildAbortRequestWithBody(server string, appSlug string, buildSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "build-slug", runtime.ParamLocationPath, buildSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/builds/%s/abort", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArtifactListRequest generates requests for ArtifactList
func NewArtifactListRequest(server string, appSlug string, buildSlug string, params *ArtifactListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "build-slug", runtime.ParamLocationPath, buildSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/builds/%s/artifacts", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArtifactDeleteRequest generates requests for ArtifactDelete
func NewArtifactDeleteRequest(server string, appSlug string, buildSlug string, artifactSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "build-slug", runtime.ParamLocationPath, buildSlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "artifact-slug", runtime.ParamLocationPath, artifactSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/builds/%s/artifacts/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArtifactShowRequest generates requests for ArtifactShow
func NewArtifactShowRequest(server string, appSlug string, buildSlug string, artifactSlug string, params *ArtifactShowParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "build-slug", runtime.ParamLocationPath, buildSlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "artifact-slug", runtime.ParamLocationPath, artifactSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/builds/%s/artifacts/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Download != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "download", runtime.ParamLocationQuery, *params.Download); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArtifactUpdateRequest calls the generic ArtifactUpdate builder with application/json body
func NewArtifactUpdateRequest(server string, appSlug string, buildSlug string, artifactSlug string, body ArtifactUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArtifactUpdateRequestWithBody(server, appSlug, buildSlug, artifactSlug, "application/json", bodyReader)
}

// NewArtifactUpdateRequestWithBody generates requests for ArtifactUpdate with any type of body
func NewArtifactUpdateRequestWithBody(server string, appSlug string, buildSlug string, artifactSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "build-slug", runtime.ParamLocationPath, buildSlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "artifact-slug", runtime.ParamLocationPath, artifactSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/builds/%s/artifacts/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBuildBitriseYmlShowRequest generates requests for BuildBitriseYmlShow
func NewBuildBitriseYmlShowRequest(server string, appSlug string, buildSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "build-slug", runtime.ParamLocationPath, buildSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/builds/%s/bitrise.yml", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildLogRequest generates requests for BuildLog
func NewBuildLogRequest(server string, appSlug string, buildSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "build-slug", runtime.ParamLocationPath, buildSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/builds/%s/log", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCacheItemDeleteAllRequest generates requests for CacheItemDeleteAll
func NewCacheItemDeleteAllRequest(server string, appSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/cache-items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCacheListRequest generates requests for CacheList
func NewCacheListRequest(server string, appSlug string, params *CacheListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/cache-items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCacheItemDeleteRequest generates requests for CacheItemDelete
func NewCacheItemDeleteRequest(server string, appSlug string, cacheItemId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cache-item-id", runtime.ParamLocationPath, cacheItemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/cache-items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCacheItemDownloadRequest generates requests for CacheItemDownload
func NewCacheItemDownloadRequest(server string, appSlug string, cacheItemId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cache-item-id", runtime.ParamLocationPath, cacheItemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/cache-items/%s/download", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppFinishRequest calls the generic AppFinish builder with application/json body
func NewAppFinishRequest(server string, appSlug string, body AppFinishJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppFinishRequestWithBody(server, appSlug, "application/json", bodyReader)
}

// NewAppFinishRequestWithBody generates requests for AppFinish with any type of body
func NewAppFinishRequestWithBody(server string, appSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/finish", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenericProjectFileListRequest generates requests for GenericProjectFileList
func NewGenericProjectFileListRequest(server string, appSlug string, params *GenericProjectFileListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/generic-project-files", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenericProjectFilesCreateRequest calls the generic GenericProjectFilesCreate builder with application/json body
func NewGenericProjectFilesCreateRequest(server string, appSlug string, body GenericProjectFilesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenericProjectFilesCreateRequestWithBody(server, appSlug, "application/json", bodyReader)
}

// NewGenericProjectFilesCreateRequestWithBody generates requests for GenericProjectFilesCreate with any type of body
func NewGenericProjectFilesCreateRequestWithBody(server string, appSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/generic-project-files", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenericProjectFileDeleteRequest generates requests for GenericProjectFileDelete
func NewGenericProjectFileDeleteRequest(server string, appSlug string, genericProjectFileSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "generic-project-file-slug", runtime.ParamLocationPath, genericProjectFileSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/generic-project-files/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenericProjectFileShowRequest generates requests for GenericProjectFileShow
func NewGenericProjectFileShowRequest(server string, appSlug string, genericProjectFileSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "generic-project-file-slug", runtime.ParamLocationPath, genericProjectFileSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/generic-project-files/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenericProjectFileUpdateRequest calls the generic GenericProjectFileUpdate builder with application/json body
func NewGenericProjectFileUpdateRequest(server string, appSlug string, genericProjectFileSlug string, body GenericProjectFileUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenericProjectFileUpdateRequestWithBody(server, appSlug, genericProjectFileSlug, "application/json", bodyReader)
}

// NewGenericProjectFileUpdateRequestWithBody generates requests for GenericProjectFileUpdate with any type of body
func NewGenericProjectFileUpdateRequestWithBody(server string, appSlug string, genericProjectFileSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "generic-project-file-slug", runtime.ParamLocationPath, genericProjectFileSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/generic-project-files/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenericProjectFileConfirmRequest generates requests for GenericProjectFileConfirm
func NewGenericProjectFileConfirmRequest(server string, appSlug string, genericProjectFileSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "generic-project-file-slug", runtime.ParamLocationPath, genericProjectFileSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/generic-project-files/%s/uploaded", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLocalBuildListRequest generates requests for LocalBuildList
func NewLocalBuildListRequest(server string, appSlug string, params *LocalBuildListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/local-builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOutgoingWebhookListRequest generates requests for OutgoingWebhookList
func NewOutgoingWebhookListRequest(server string, appSlug string, params *OutgoingWebhookListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/outgoing-webhooks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOutgoingWebhookCreateRequestWithBody generates requests for OutgoingWebhookCreate with any type of body
func NewOutgoingWebhookCreateRequestWithBody(server string, appSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/outgoing-webhooks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOutgoingWebhookDeleteRequest generates requests for OutgoingWebhookDelete
func NewOutgoingWebhookDeleteRequest(server string, appSlug string, appWebhookSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app-webhook-slug", runtime.ParamLocationPath, appWebhookSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/outgoing-webhooks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOutgoingWebhookUpdateRequestWithBody generates requests for OutgoingWebhookUpdate with any type of body
func NewOutgoingWebhookUpdateRequestWithBody(server string, appSlug string, appWebhookSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app-webhook-slug", runtime.ParamLocationPath, appWebhookSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/outgoing-webhooks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWebhookDeliveryItemListRequest generates requests for WebhookDeliveryItemList
func NewWebhookDeliveryItemListRequest(server string, appSlug string, appWebhookSlug string, params *WebhookDeliveryItemListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app-webhook-slug", runtime.ParamLocationPath, appWebhookSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/outgoing-webhooks/%s/delivery-items", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWebhookDeliveryItemShowRequest generates requests for WebhookDeliveryItemShow
func NewWebhookDeliveryItemShowRequest(server string, appSlug string, appWebhookSlug string, webhookDeliveryItemSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app-webhook-slug", runtime.ParamLocationPath, appWebhookSlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "webhook-delivery-item-slug", runtime.ParamLocationPath, webhookDeliveryItemSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/outgoing-webhooks/%s/delivery-items/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWebhookDeliveryItemRedeliverRequest generates requests for WebhookDeliveryItemRedeliver
func NewWebhookDeliveryItemRedeliverRequest(server string, appSlug string, appWebhookSlug string, webhookDeliveryItemSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app-webhook-slug", runtime.ParamLocationPath, appWebhookSlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "webhook-delivery-item-slug", runtime.ParamLocationPath, webhookDeliveryItemSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/outgoing-webhooks/%s/delivery-items/%s/redeliver", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPipelineListRequest generates requests for PipelineList
func NewPipelineListRequest(server string, appSlug string, params *PipelineListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/pipelines", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Branch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "branch", runtime.ParamLocationQuery, *params.Branch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BuildNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "build_number", runtime.ParamLocationQuery, *params.BuildNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BuildEnvironment != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "build_environment", runtime.ParamLocationQuery, *params.BuildEnvironment); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CommitMessage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "commit_message", runtime.ParamLocationQuery, *params.CommitMessage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pipeline != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pipeline", runtime.ParamLocationQuery, *params.Pipeline); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TriggerEventType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trigger_event_type", runtime.ParamLocationQuery, *params.TriggerEventType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Workflow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workflow", runtime.ParamLocationQuery, *params.Workflow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPipelineShowRequest generates requests for PipelineShow
func NewPipelineShowRequest(server string, appSlug string, pipelineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pipeline-id", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/pipelines/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPipelineAbortRequestWithBody generates requests for PipelineAbort with any type of body
func NewPipelineAbortRequestWithBody(server string, appSlug string, pipelineId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pipeline-id", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/pipelines/%s/abort", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPipelineRebuildRequestWithBody generates requests for PipelineRebuild with any type of body
func NewPipelineRebuildRequestWithBody(server string, appSlug string, pipelineId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pipeline-id", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/pipelines/%s/rebuild", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProvisioningProfileListRequest generates requests for ProvisioningProfileList
func NewProvisioningProfileListRequest(server string, appSlug string, params *ProvisioningProfileListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/provisioning-profiles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProvisioningProfileCreateRequest calls the generic ProvisioningProfileCreate builder with application/json body
func NewProvisioningProfileCreateRequest(server string, appSlug string, body ProvisioningProfileCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProvisioningProfileCreateRequestWithBody(server, appSlug, "application/json", bodyReader)
}

// NewProvisioningProfileCreateRequestWithBody generates requests for ProvisioningProfileCreate with any type of body
func NewProvisioningProfileCreateRequestWithBody(server string, appSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/provisioning-profiles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProvisioningProfileDeleteRequest generates requests for ProvisioningProfileDelete
func NewProvisioningProfileDeleteRequest(server string, appSlug string, provisioningProfileSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "provisioning-profile-slug", runtime.ParamLocationPath, provisioningProfileSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/provisioning-profiles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProvisioningProfileShowRequest generates requests for ProvisioningProfileShow
func NewProvisioningProfileShowRequest(server string, appSlug string, provisioningProfileSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "provisioning-profile-slug", runtime.ParamLocationPath, provisioningProfileSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/provisioning-profiles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProvisioningProfileUpdateRequest calls the generic ProvisioningProfileUpdate builder with application/json body
func NewProvisioningProfileUpdateRequest(server string, appSlug string, provisioningProfileSlug string, body ProvisioningProfileUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProvisioningProfileUpdateRequestWithBody(server, appSlug, provisioningProfileSlug, "application/json", bodyReader)
}

// NewProvisioningProfileUpdateRequestWithBody generates requests for ProvisioningProfileUpdate with any type of body
func NewProvisioningProfileUpdateRequestWithBody(server string, appSlug string, provisioningProfileSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "provisioning-profile-slug", runtime.ParamLocationPath, provisioningProfileSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/provisioning-profiles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProvisioningProfileConfirmRequest generates requests for ProvisioningProfileConfirm
func NewProvisioningProfileConfirmRequest(server string, appSlug string, provisioningProfileSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "provisioning-profile-slug", runtime.ParamLocationPath, provisioningProfileSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/provisioning-profiles/%s/uploaded", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSshKeyCreateRequest calls the generic SshKeyCreate builder with application/json body
func NewSshKeyCreateRequest(server string, appSlug string, body SshKeyCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSshKeyCreateRequestWithBody(server, appSlug, "application/json", bodyReader)
}

// NewSshKeyCreateRequestWithBody generates requests for SshKeyCreate with any type of body
func NewSshKeyCreateRequestWithBody(server string, appSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/register-ssh-key", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAppWebhookCreateRequest generates requests for AppWebhookCreate
func NewAppWebhookCreateRequest(server string, appSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/register-webhook", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReleaseCreateAppStoreRequest calls the generic ReleaseCreateAppStore builder with application/json body
func NewReleaseCreateAppStoreRequest(server string, appSlug string, body ReleaseCreateAppStoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReleaseCreateAppStoreRequestWithBody(server, appSlug, "application/json", bodyReader)
}

// NewReleaseCreateAppStoreRequestWithBody generates requests for ReleaseCreateAppStore with any type of body
func NewReleaseCreateAppStoreRequestWithBody(server string, appSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/releases/app-store", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReleaseCreateGooglePlayRequest calls the generic ReleaseCreateGooglePlay builder with application/json body
func NewReleaseCreateGooglePlayRequest(server string, appSlug string, body ReleaseCreateGooglePlayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReleaseCreateGooglePlayRequestWithBody(server, appSlug, "application/json", bodyReader)
}

// NewReleaseCreateGooglePlayRequestWithBody generates requests for ReleaseCreateGooglePlay with any type of body
func NewReleaseCreateGooglePlayRequestWithBody(server string, appSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/releases/google-play", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAppRolesQueryRequest generates requests for AppRolesQuery
func NewAppRolesQueryRequest(server string, appSlug string, roleName AppRolesQueryParamsRoleName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "role-name", runtime.ParamLocationPath, roleName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppRolesUpdateRequestWithBody generates requests for AppRolesUpdate with any type of body
func NewAppRolesUpdateRequestWithBody(server string, appSlug string, roleName AppRolesUpdateParamsRoleName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "role-name", runtime.ParamLocationPath, roleName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSecretListRequest generates requests for SecretList
func NewSecretListRequest(server string, appSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/secrets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSecretDeleteRequest generates requests for SecretDelete
func NewSecretDeleteRequest(server string, appSlug string, secretName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "secret-name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/secrets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSecretUpsertRequest calls the generic SecretUpsert builder with application/json body
func NewSecretUpsertRequest(server string, appSlug string, secretName string, body SecretUpsertJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSecretUpsertRequestWithBody(server, appSlug, secretName, "application/json", bodyReader)
}

// NewSecretUpsertRequestWithBody generates requests for SecretUpsert with any type of body
func NewSecretUpsertRequestWithBody(server string, appSlug string, secretName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "secret-name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/secrets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSecretValueGetRequest generates requests for SecretValueGet
func NewSecretValueGetRequest(server string, appSlug string, secretName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "secret-name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/secrets/%s/value", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestDeviceListRequest generates requests for TestDeviceList
func NewTestDeviceListRequest(server string, appSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/test-devices", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppNotificationsRequest calls the generic AppNotifications builder with application/json body
func NewAppNotificationsRequest(server string, appSlug string, body AppNotificationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppNotificationsRequestWithBody(server, appSlug, "application/json", bodyReader)
}

// NewAppNotificationsRequestWithBody generates requests for AppNotifications with any type of body
func NewAppNotificationsRequestWithBody(server string, appSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app-slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/update-email-notifications", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBuildListAllRequest generates requests for BuildListAll
func NewBuildListAllRequest(server string, params *BuildListAllParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/builds")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OwnerSlug != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "owner_slug", runtime.ParamLocationQuery, *params.OwnerSlug); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsOnHold != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_on_hold", runtime.ParamLocationQuery, *params.IsOnHold); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserProfileRequest generates requests for UserProfile
func NewUserProfileRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivityListRequest generates requests for ActivityList
func NewActivityListRequest(server string, params *ActivityListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/activities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserPlanRequest generates requests for UserPlan
func NewUserPlanRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/plan")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgListRequest generates requests for OrgList
func NewOrgListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgShowRequest generates requests for OrgShow
func NewOrgShowRequest(server string, orgSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org-slug", runtime.ParamLocationPath, orgSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppListByOrganizationRequest generates requests for AppListByOrganization
func NewAppListByOrganizationRequest(server string, orgSlug string, params *AppListByOrganizationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org-slug", runtime.ParamLocationPath, orgSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/apps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Title != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_type", runtime.ParamLocationQuery, *params.ProjectType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrganizationMachineTypeUpdateRequest calls the generic OrganizationMachineTypeUpdate builder with application/json body
func NewOrganizationMachineTypeUpdateRequest(server string, orgSlug string, body OrganizationMachineTypeUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrganizationMachineTypeUpdateRequestWithBody(server, orgSlug, "application/json", bodyReader)
}

// NewOrganizationMachineTypeUpdateRequestWithBody generates requests for OrganizationMachineTypeUpdate with any type of body
func NewOrganizationMachineTypeUpdateRequestWithBody(server string, orgSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org-slug", runtime.ParamLocationPath, orgSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/apps/machine_types", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrganzationGroupsListRequest generates requests for OrganzationGroupsList
func NewOrganzationGroupsListRequest(server string, orgSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org-slug", runtime.ParamLocationPath, orgSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddonListByOrganizationRequest generates requests for AddonListByOrganization
func NewAddonListByOrganizationRequest(server string, organizationSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization-slug", runtime.ParamLocationPath, organizationSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/addons", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPipelineListAllRequest generates requests for PipelineListAll
func NewPipelineListAllRequest(server string, params *PipelineListAllParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pipelines")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OwnerSlug != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "owner_slug", runtime.ParamLocationQuery, *params.OwnerSlug); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserMachineTypeUpdateRequest calls the generic UserMachineTypeUpdate builder with application/json body
func NewUserMachineTypeUpdateRequest(server string, userSlug string, body UserMachineTypeUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserMachineTypeUpdateRequestWithBody(server, userSlug, "application/json", bodyReader)
}

// NewUserMachineTypeUpdateRequestWithBody generates requests for UserMachineTypeUpdate with any type of body
func NewUserMachineTypeUpdateRequestWithBody(server string, userSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-slug", runtime.ParamLocationPath, userSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/apps/machine_types", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserShowRequest generates requests for UserShow
func NewUserShowRequest(server string, userSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-slug", runtime.ParamLocationPath, userSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddonListByUserRequest generates requests for AddonListByUser
func NewAddonListByUserRequest(server string, userSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-slug", runtime.ParamLocationPath, userSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/addons", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppleApiCredentialListRequest generates requests for AppleApiCredentialList
func NewAppleApiCredentialListRequest(server string, userSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-slug", runtime.ParamLocationPath, userSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/apple-api-credentials", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppListByUserRequest generates requests for AppListByUser
func NewAppListByUserRequest(server string, userSlug string, params *AppListByUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-slug", runtime.ParamLocationPath, userSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/apps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Title != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_type", runtime.ParamLocationQuery, *params.ProjectType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AddonsListWithResponse request
	AddonsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AddonsListResponse, error)

	// AddonsShowWithResponse request
	AddonsShowWithResponse(ctx context.Context, addonId string, reqEditors ...RequestEditorFn) (*AddonsShowResponse, error)

	// AppListWithResponse request
	AppListWithResponse(ctx context.Context, params *AppListParams, reqEditors ...RequestEditorFn) (*AppListResponse, error)

	// AppCreateWithBodyWithResponse request with any body
	AppCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppCreateResponse, error)

	AppCreateWithResponse(ctx context.Context, body AppCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AppCreateResponse, error)

	// AppDeleteWithResponse request
	AppDeleteWithResponse(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*AppDeleteResponse, error)

	// AppShowWithResponse request
	AppShowWithResponse(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*AppShowResponse, error)

	// AppUpdateWithBodyWithResponse request with any body
	AppUpdateWithBodyWithResponse(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppUpdateResponse, error)

	AppUpdateWithResponse(ctx context.Context, appSlug string, body AppUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*AppUpdateResponse, error)

	// AddonListByAppWithResponse request
	AddonListByAppWithResponse(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*AddonListByAppResponse, error)

	// AndroidKeystoreFileListWithResponse request
	AndroidKeystoreFileListWithResponse(ctx context.Context, appSlug string, params *AndroidKeystoreFileListParams, reqEditors ...RequestEditorFn) (*AndroidKeystoreFileListResponse, error)

	// AndroidKeystoreFileCreateWithBodyWithResponse request with any body
	AndroidKeystoreFileCreateWithBodyWithResponse(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AndroidKeystoreFileCreateResponse, error)

	AndroidKeystoreFileCreateWithResponse(ctx context.Context, appSlug string, body AndroidKeystoreFileCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AndroidKeystoreFileCreateResponse, error)

	// AndroidKeystoreFileDeleteWithResponse request
	AndroidKeystoreFileDeleteWithResponse(ctx context.Context, appSlug string, androidKeystoreFileSlug string, reqEditors ...RequestEditorFn) (*AndroidKeystoreFileDeleteResponse, error)

	// AndroidKeystoreFileConfirmWithResponse request
	AndroidKeystoreFileConfirmWithResponse(ctx context.Context, appSlug string, androidKeystoreFileSlug string, reqEditors ...RequestEditorFn) (*AndroidKeystoreFileConfirmResponse, error)

	// ArchivedBuildsListWithResponse request
	ArchivedBuildsListWithResponse(ctx context.Context, appSlug string, params *ArchivedBuildsListParams, reqEditors ...RequestEditorFn) (*ArchivedBuildsListResponse, error)

	// AppConfigDatastoreShowWithResponse request
	AppConfigDatastoreShowWithResponse(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*AppConfigDatastoreShowResponse, error)

	// AppConfigCreateWithBodyWithResponse request with any body
	AppConfigCreateWithBodyWithResponse(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppConfigCreateResponse, error)

	AppConfigCreateWithResponse(ctx context.Context, appSlug string, body AppConfigCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AppConfigCreateResponse, error)

	// AppSetupBitriseYmlConfigGetWithResponse request
	AppSetupBitriseYmlConfigGetWithResponse(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*AppSetupBitriseYmlConfigGetResponse, error)

	// AppSetupBitriseYmlConfigUpdateWithBodyWithResponse request with any body
	AppSetupBitriseYmlConfigUpdateWithBodyWithResponse(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppSetupBitriseYmlConfigUpdateResponse, error)

	AppSetupBitriseYmlConfigUpdateWithResponse(ctx context.Context, appSlug string, body AppSetupBitriseYmlConfigUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*AppSetupBitriseYmlConfigUpdateResponse, error)

	// BranchListWithResponse request
	BranchListWithResponse(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*BranchListResponse, error)

	// BuildCertificateListWithResponse request
	BuildCertificateListWithResponse(ctx context.Context, appSlug string, params *BuildCertificateListParams, reqEditors ...RequestEditorFn) (*BuildCertificateListResponse, error)

	// BuildCertificateCreateWithBodyWithResponse request with any body
	BuildCertificateCreateWithBodyWithResponse(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BuildCertificateCreateResponse, error)

	BuildCertificateCreateWithResponse(ctx context.Context, appSlug string, body BuildCertificateCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*BuildCertificateCreateResponse, error)

	// BuildCertificateDeleteWithResponse request
	BuildCertificateDeleteWithResponse(ctx context.Context, appSlug string, buildCertificateSlug string, reqEditors ...RequestEditorFn) (*BuildCertificateDeleteResponse, error)

	// BuildCertificateShowWithResponse request
	BuildCertificateShowWithResponse(ctx context.Context, appSlug string, buildCertificateSlug string, reqEditors ...RequestEditorFn) (*BuildCertificateShowResponse, error)

	// BuildCertificateUpdateWithBodyWithResponse request with any body
	BuildCertificateUpdateWithBodyWithResponse(ctx context.Context, appSlug string, buildCertificateSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BuildCertificateUpdateResponse, error)

	BuildCertificateUpdateWithResponse(ctx context.Context, appSlug string, buildCertificateSlug string, body BuildCertificateUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*BuildCertificateUpdateResponse, error)

	// BuildCertificateConfirmWithResponse request
	BuildCertificateConfirmWithResponse(ctx context.Context, appSlug string, buildCertificateSlug string, reqEditors ...RequestEditorFn) (*BuildCertificateConfirmResponse, error)

	// BuildRequestListWithResponse request
	BuildRequestListWithResponse(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*BuildRequestListResponse, error)

	// BuildRequestUpdateWithBodyWithResponse request with any body
	BuildRequestUpdateWithBodyWithResponse(ctx context.Context, appSlug string, buildRequestSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BuildRequestUpdateResponse, error)

	BuildRequestUpdateWithResponse(ctx context.Context, appSlug string, buildRequestSlug string, body BuildRequestUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*BuildRequestUpdateResponse, error)

	// BuildWorkflowListWithResponse request
	BuildWorkflowListWithResponse(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*BuildWorkflowListResponse, error)

	// BuildListWithResponse request
	BuildListWithResponse(ctx context.Context, appSlug string, params *BuildListParams, reqEditors ...RequestEditorFn) (*BuildListResponse, error)

	// BuildTriggerWithBodyWithResponse request with any body
	BuildTriggerWithBodyWithResponse(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BuildTriggerResponse, error)

	BuildTriggerWithResponse(ctx context.Context, appSlug string, body BuildTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*BuildTriggerResponse, error)

	// BuildShowWithResponse request
	BuildShowWithResponse(ctx context.Context, appSlug string, buildSlug string, reqEditors ...RequestEditorFn) (*BuildShowResponse, error)

	// BuildAbortWithBodyWithResponse request with any body
	BuildAbortWithBodyWithResponse(ctx context.Context, appSlug string, buildSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BuildAbortResponse, error)

	BuildAbortWithResponse(ctx context.Context, appSlug string, buildSlug string, body BuildAbortJSONRequestBody, reqEditors ...RequestEditorFn) (*BuildAbortResponse, error)

	// ArtifactListWithResponse request
	ArtifactListWithResponse(ctx context.Context, appSlug string, buildSlug string, params *ArtifactListParams, reqEditors ...RequestEditorFn) (*ArtifactListResponse, error)

	// ArtifactDeleteWithResponse request
	ArtifactDeleteWithResponse(ctx context.Context, appSlug string, buildSlug string, artifactSlug string, reqEditors ...RequestEditorFn) (*ArtifactDeleteResponse, error)

	// ArtifactShowWithResponse request
	ArtifactShowWithResponse(ctx context.Context, appSlug string, buildSlug string, artifactSlug string, params *ArtifactShowParams, reqEditors ...RequestEditorFn) (*ArtifactShowResponse, error)

	// ArtifactUpdateWithBodyWithResponse request with any body
	ArtifactUpdateWithBodyWithResponse(ctx context.Context, appSlug string, buildSlug string, artifactSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArtifactUpdateResponse, error)

	ArtifactUpdateWithResponse(ctx context.Context, appSlug string, buildSlug string, artifactSlug string, body ArtifactUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ArtifactUpdateResponse, error)

	// BuildBitriseYmlShowWithResponse request
	BuildBitriseYmlShowWithResponse(ctx context.Context, appSlug string, buildSlug string, reqEditors ...RequestEditorFn) (*BuildBitriseYmlShowResponse, error)

	// BuildLogWithResponse request
	BuildLogWithResponse(ctx context.Context, appSlug string, buildSlug string, reqEditors ...RequestEditorFn) (*BuildLogResponse, error)

	// CacheItemDeleteAllWithResponse request
	CacheItemDeleteAllWithResponse(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*CacheItemDeleteAllResponse, error)

	// CacheListWithResponse request
	CacheListWithResponse(ctx context.Context, appSlug string, params *CacheListParams, reqEditors ...RequestEditorFn) (*CacheListResponse, error)

	// CacheItemDeleteWithResponse request
	CacheItemDeleteWithResponse(ctx context.Context, appSlug string, cacheItemId string, reqEditors ...RequestEditorFn) (*CacheItemDeleteResponse, error)

	// CacheItemDownloadWithResponse request
	CacheItemDownloadWithResponse(ctx context.Context, appSlug string, cacheItemId string, reqEditors ...RequestEditorFn) (*CacheItemDownloadResponse, error)

	// AppFinishWithBodyWithResponse request with any body
	AppFinishWithBodyWithResponse(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppFinishResponse, error)

	AppFinishWithResponse(ctx context.Context, appSlug string, body AppFinishJSONRequestBody, reqEditors ...RequestEditorFn) (*AppFinishResponse, error)

	// GenericProjectFileListWithResponse request
	GenericProjectFileListWithResponse(ctx context.Context, appSlug string, params *GenericProjectFileListParams, reqEditors ...RequestEditorFn) (*GenericProjectFileListResponse, error)

	// GenericProjectFilesCreateWithBodyWithResponse request with any body
	GenericProjectFilesCreateWithBodyWithResponse(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenericProjectFilesCreateResponse, error)

	GenericProjectFilesCreateWithResponse(ctx context.Context, appSlug string, body GenericProjectFilesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*GenericProjectFilesCreateResponse, error)

	// GenericProjectFileDeleteWithResponse request
	GenericProjectFileDeleteWithResponse(ctx context.Context, appSlug string, genericProjectFileSlug string, reqEditors ...RequestEditorFn) (*GenericProjectFileDeleteResponse, error)

	// GenericProjectFileShowWithResponse request
	GenericProjectFileShowWithResponse(ctx context.Context, appSlug string, genericProjectFileSlug string, reqEditors ...RequestEditorFn) (*GenericProjectFileShowResponse, error)

	// GenericProjectFileUpdateWithBodyWithResponse request with any body
	GenericProjectFileUpdateWithBodyWithResponse(ctx context.Context, appSlug string, genericProjectFileSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenericProjectFileUpdateResponse, error)

	GenericProjectFileUpdateWithResponse(ctx context.Context, appSlug string, genericProjectFileSlug string, body GenericProjectFileUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*GenericProjectFileUpdateResponse, error)

	// GenericProjectFileConfirmWithResponse request
	GenericProjectFileConfirmWithResponse(ctx context.Context, appSlug string, genericProjectFileSlug string, reqEditors ...RequestEditorFn) (*GenericProjectFileConfirmResponse, error)

	// LocalBuildListWithResponse request
	LocalBuildListWithResponse(ctx context.Context, appSlug string, params *LocalBuildListParams, reqEditors ...RequestEditorFn) (*LocalBuildListResponse, error)

	// OutgoingWebhookListWithResponse request
	OutgoingWebhookListWithResponse(ctx context.Context, appSlug string, params *OutgoingWebhookListParams, reqEditors ...RequestEditorFn) (*OutgoingWebhookListResponse, error)

	// OutgoingWebhookCreateWithBodyWithResponse request with any body
	OutgoingWebhookCreateWithBodyWithResponse(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OutgoingWebhookCreateResponse, error)

	// OutgoingWebhookDeleteWithResponse request
	OutgoingWebhookDeleteWithResponse(ctx context.Context, appSlug string, appWebhookSlug string, reqEditors ...RequestEditorFn) (*OutgoingWebhookDeleteResponse, error)

	// OutgoingWebhookUpdateWithBodyWithResponse request with any body
	OutgoingWebhookUpdateWithBodyWithResponse(ctx context.Context, appSlug string, appWebhookSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OutgoingWebhookUpdateResponse, error)

	// WebhookDeliveryItemListWithResponse request
	WebhookDeliveryItemListWithResponse(ctx context.Context, appSlug string, appWebhookSlug string, params *WebhookDeliveryItemListParams, reqEditors ...RequestEditorFn) (*WebhookDeliveryItemListResponse, error)

	// WebhookDeliveryItemShowWithResponse request
	WebhookDeliveryItemShowWithResponse(ctx context.Context, appSlug string, appWebhookSlug string, webhookDeliveryItemSlug string, reqEditors ...RequestEditorFn) (*WebhookDeliveryItemShowResponse, error)

	// WebhookDeliveryItemRedeliverWithResponse request
	WebhookDeliveryItemRedeliverWithResponse(ctx context.Context, appSlug string, appWebhookSlug string, webhookDeliveryItemSlug string, reqEditors ...RequestEditorFn) (*WebhookDeliveryItemRedeliverResponse, error)

	// PipelineListWithResponse request
	PipelineListWithResponse(ctx context.Context, appSlug string, params *PipelineListParams, reqEditors ...RequestEditorFn) (*PipelineListResponse, error)

	// PipelineShowWithResponse request
	PipelineShowWithResponse(ctx context.Context, appSlug string, pipelineId string, reqEditors ...RequestEditorFn) (*PipelineShowResponse, error)

	// PipelineAbortWithBodyWithResponse request with any body
	PipelineAbortWithBodyWithResponse(ctx context.Context, appSlug string, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PipelineAbortResponse, error)

	// PipelineRebuildWithBodyWithResponse request with any body
	PipelineRebuildWithBodyWithResponse(ctx context.Context, appSlug string, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PipelineRebuildResponse, error)

	// ProvisioningProfileListWithResponse request
	ProvisioningProfileListWithResponse(ctx context.Context, appSlug string, params *ProvisioningProfileListParams, reqEditors ...RequestEditorFn) (*ProvisioningProfileListResponse, error)

	// ProvisioningProfileCreateWithBodyWithResponse request with any body
	ProvisioningProfileCreateWithBodyWithResponse(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProvisioningProfileCreateResponse, error)

	ProvisioningProfileCreateWithResponse(ctx context.Context, appSlug string, body ProvisioningProfileCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProvisioningProfileCreateResponse, error)

	// ProvisioningProfileDeleteWithResponse request
	ProvisioningProfileDeleteWithResponse(ctx context.Context, appSlug string, provisioningProfileSlug string, reqEditors ...RequestEditorFn) (*ProvisioningProfileDeleteResponse, error)

	// ProvisioningProfileShowWithResponse request
	ProvisioningProfileShowWithResponse(ctx context.Context, appSlug string, provisioningProfileSlug string, reqEditors ...RequestEditorFn) (*ProvisioningProfileShowResponse, error)

	// ProvisioningProfileUpdateWithBodyWithResponse request with any body
	ProvisioningProfileUpdateWithBodyWithResponse(ctx context.Context, appSlug string, provisioningProfileSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProvisioningProfileUpdateResponse, error)

	ProvisioningProfileUpdateWithResponse(ctx context.Context, appSlug string, provisioningProfileSlug string, body ProvisioningProfileUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProvisioningProfileUpdateResponse, error)

	// ProvisioningProfileConfirmWithResponse request
	ProvisioningProfileConfirmWithResponse(ctx context.Context, appSlug string, provisioningProfileSlug string, reqEditors ...RequestEditorFn) (*ProvisioningProfileConfirmResponse, error)

	// SshKeyCreateWithBodyWithResponse request with any body
	SshKeyCreateWithBodyWithResponse(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SshKeyCreateResponse, error)

	SshKeyCreateWithResponse(ctx context.Context, appSlug string, body SshKeyCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SshKeyCreateResponse, error)

	// AppWebhookCreateWithResponse request
	AppWebhookCreateWithResponse(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*AppWebhookCreateResponse, error)

	// ReleaseCreateAppStoreWithBodyWithResponse request with any body
	ReleaseCreateAppStoreWithBodyWithResponse(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReleaseCreateAppStoreResponse, error)

	ReleaseCreateAppStoreWithResponse(ctx context.Context, appSlug string, body ReleaseCreateAppStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*ReleaseCreateAppStoreResponse, error)

	// ReleaseCreateGooglePlayWithBodyWithResponse request with any body
	ReleaseCreateGooglePlayWithBodyWithResponse(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReleaseCreateGooglePlayResponse, error)

	ReleaseCreateGooglePlayWithResponse(ctx context.Context, appSlug string, body ReleaseCreateGooglePlayJSONRequestBody, reqEditors ...RequestEditorFn) (*ReleaseCreateGooglePlayResponse, error)

	// AppRolesQueryWithResponse request
	AppRolesQueryWithResponse(ctx context.Context, appSlug string, roleName AppRolesQueryParamsRoleName, reqEditors ...RequestEditorFn) (*AppRolesQueryResponse, error)

	// AppRolesUpdateWithBodyWithResponse request with any body
	AppRolesUpdateWithBodyWithResponse(ctx context.Context, appSlug string, roleName AppRolesUpdateParamsRoleName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppRolesUpdateResponse, error)

	// SecretListWithResponse request
	SecretListWithResponse(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*SecretListResponse, error)

	// SecretDeleteWithResponse request
	SecretDeleteWithResponse(ctx context.Context, appSlug string, secretName string, reqEditors ...RequestEditorFn) (*SecretDeleteResponse, error)

	// SecretUpsertWithBodyWithResponse request with any body
	SecretUpsertWithBodyWithResponse(ctx context.Context, appSlug string, secretName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SecretUpsertResponse, error)

	SecretUpsertWithResponse(ctx context.Context, appSlug string, secretName string, body SecretUpsertJSONRequestBody, reqEditors ...RequestEditorFn) (*SecretUpsertResponse, error)

	// SecretValueGetWithResponse request
	SecretValueGetWithResponse(ctx context.Context, appSlug string, secretName string, reqEditors ...RequestEditorFn) (*SecretValueGetResponse, error)

	// TestDeviceListWithResponse request
	TestDeviceListWithResponse(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*TestDeviceListResponse, error)

	// AppNotificationsWithBodyWithResponse request with any body
	AppNotificationsWithBodyWithResponse(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppNotificationsResponse, error)

	AppNotificationsWithResponse(ctx context.Context, appSlug string, body AppNotificationsJSONRequestBody, reqEditors ...RequestEditorFn) (*AppNotificationsResponse, error)

	// BuildListAllWithResponse request
	BuildListAllWithResponse(ctx context.Context, params *BuildListAllParams, reqEditors ...RequestEditorFn) (*BuildListAllResponse, error)

	// UserProfileWithResponse request
	UserProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserProfileResponse, error)

	// ActivityListWithResponse request
	ActivityListWithResponse(ctx context.Context, params *ActivityListParams, reqEditors ...RequestEditorFn) (*ActivityListResponse, error)

	// UserPlanWithResponse request
	UserPlanWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserPlanResponse, error)

	// OrgListWithResponse request
	OrgListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OrgListResponse, error)

	// OrgShowWithResponse request
	OrgShowWithResponse(ctx context.Context, orgSlug string, reqEditors ...RequestEditorFn) (*OrgShowResponse, error)

	// AppListByOrganizationWithResponse request
	AppListByOrganizationWithResponse(ctx context.Context, orgSlug string, params *AppListByOrganizationParams, reqEditors ...RequestEditorFn) (*AppListByOrganizationResponse, error)

	// OrganizationMachineTypeUpdateWithBodyWithResponse request with any body
	OrganizationMachineTypeUpdateWithBodyWithResponse(ctx context.Context, orgSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrganizationMachineTypeUpdateResponse, error)

	OrganizationMachineTypeUpdateWithResponse(ctx context.Context, orgSlug string, body OrganizationMachineTypeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*OrganizationMachineTypeUpdateResponse, error)

	// OrganzationGroupsListWithResponse request
	OrganzationGroupsListWithResponse(ctx context.Context, orgSlug string, reqEditors ...RequestEditorFn) (*OrganzationGroupsListResponse, error)

	// AddonListByOrganizationWithResponse request
	AddonListByOrganizationWithResponse(ctx context.Context, organizationSlug string, reqEditors ...RequestEditorFn) (*AddonListByOrganizationResponse, error)

	// PipelineListAllWithResponse request
	PipelineListAllWithResponse(ctx context.Context, params *PipelineListAllParams, reqEditors ...RequestEditorFn) (*PipelineListAllResponse, error)

	// UserMachineTypeUpdateWithBodyWithResponse request with any body
	UserMachineTypeUpdateWithBodyWithResponse(ctx context.Context, userSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserMachineTypeUpdateResponse, error)

	UserMachineTypeUpdateWithResponse(ctx context.Context, userSlug string, body UserMachineTypeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserMachineTypeUpdateResponse, error)

	// UserShowWithResponse request
	UserShowWithResponse(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*UserShowResponse, error)

	// AddonListByUserWithResponse request
	AddonListByUserWithResponse(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*AddonListByUserResponse, error)

	// AppleApiCredentialListWithResponse request
	AppleApiCredentialListWithResponse(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*AppleApiCredentialListResponse, error)

	// AppListByUserWithResponse request
	AppListByUserWithResponse(ctx context.Context, userSlug string, params *AppListByUserParams, reqEditors ...RequestEditorFn) (*AppListByUserResponse, error)
}

type AddonsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0AddonsListResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r AddonsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddonsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddonsShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0AddonsShowResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r AddonsShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddonsShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0AppListResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r AppListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0AppRespModel
	JSON400      *ServiceProxyErrorRespModel
	JSON401      *ServiceProxyErrorRespModel
	JSON404      *ServiceProxyErrorRespModel
	JSON500      *ServiceProxyErrorRespModel
}

// Status returns HTTPResponse.Status
func (r AppCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0AppDeleteRespModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r AppDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0AppShowResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r AppShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0AppUpdateRespModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r AppUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddonListByAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0AppAddOnsListResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r AddonListByAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddonListByAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AndroidKeystoreFileListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0ProjectFileStorageListResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r AndroidKeystoreFileListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AndroidKeystoreFileListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AndroidKeystoreFileCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *V0ProjectFileStorageResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r AndroidKeystoreFileCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AndroidKeystoreFileCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AndroidKeystoreFileDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0ProjectFileStorageResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r AndroidKeystoreFileDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AndroidKeystoreFileDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AndroidKeystoreFileConfirmResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0ProjectFileStorageResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r AndroidKeystoreFileConfirmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AndroidKeystoreFileConfirmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchivedBuildsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0ArchivedBuildListResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r ArchivedBuildsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchivedBuildsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppConfigDatastoreShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AppConfigDatastoreShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppConfigDatastoreShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppConfigCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0AppConfigRespModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceProxyErrorRespModel
}

// Status returns HTTPResponse.Status
func (r AppConfigCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppConfigCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppSetupBitriseYmlConfigGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0BitriseYMLConfigGetResponse
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r AppSetupBitriseYmlConfigGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppSetupBitriseYmlConfigGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppSetupBitriseYmlConfigUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r AppSetupBitriseYmlConfigUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppSetupBitriseYmlConfigUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BranchListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0BranchListResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r BranchListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BranchListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildCertificateListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0BuildCertificateListResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r BuildCertificateListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildCertificateListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildCertificateCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *V0BuildCertificateResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r BuildCertificateCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildCertificateCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildCertificateDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0BuildCertificateResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r BuildCertificateDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildCertificateDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildCertificateShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0BuildCertificateResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r BuildCertificateShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildCertificateShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildCertificateUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0BuildCertificateResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r BuildCertificateUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildCertificateUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildCertificateConfirmResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0BuildCertificateResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r BuildCertificateConfirmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildCertificateConfirmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildRequestListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0BuildRequestListResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r BuildRequestListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildRequestListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildRequestUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0BuildRequestUpdateResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r BuildRequestUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildRequestUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildWorkflowListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0BuildWorkflowListResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r BuildWorkflowListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildWorkflowListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0BuildListResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r BuildListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *V0BuildTriggerRespModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r BuildTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0BuildShowResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r BuildShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildAbortResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0BuildAbortResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON429      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r BuildAbortResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildAbortResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArtifactListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0ArtifactListResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r ArtifactListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArtifactListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArtifactDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0ArtifactDeleteResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r ArtifactDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArtifactDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArtifactShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0ArtifactShowResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r ArtifactShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArtifactShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArtifactUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0ArtifactShowResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r ArtifactUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArtifactUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildBitriseYmlShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BuildBitriseYmlShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildBitriseYmlShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r BuildLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CacheItemDeleteAllResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r CacheItemDeleteAllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CacheItemDeleteAllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CacheListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0CacheItemListResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r CacheListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CacheListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CacheItemDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r CacheItemDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CacheItemDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CacheItemDownloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0CacheItemDownloadResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r CacheItemDownloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CacheItemDownloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppFinishResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0AppFinishRespModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r AppFinishResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppFinishResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenericProjectFileListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0ProjectFileStorageListResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r GenericProjectFileListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenericProjectFileListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenericProjectFilesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *V0ProjectFileStorageResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r GenericProjectFilesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenericProjectFilesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenericProjectFileDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0ProjectFileStorageResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r GenericProjectFileDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenericProjectFileDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenericProjectFileShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0ProjectFileStorageResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r GenericProjectFileShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenericProjectFileShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenericProjectFileUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0ProjectFileStorageResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r GenericProjectFileUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenericProjectFileUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenericProjectFileConfirmResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0ProjectFileStorageResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r GenericProjectFileConfirmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenericProjectFileConfirmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LocalBuildListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0PipelineListResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r LocalBuildListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LocalBuildListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OutgoingWebhookListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0AppWebhookListResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r OutgoingWebhookListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OutgoingWebhookListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OutgoingWebhookCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0AppWebhookCreatedResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r OutgoingWebhookCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OutgoingWebhookCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OutgoingWebhookDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0AppWebhookDeletedResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r OutgoingWebhookDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OutgoingWebhookDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OutgoingWebhookUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0AppWebhookResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r OutgoingWebhookUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OutgoingWebhookUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhookDeliveryItemListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0WebhookDeliveryItemShowResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r WebhookDeliveryItemListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhookDeliveryItemListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhookDeliveryItemShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0WebhookDeliveryItemResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r WebhookDeliveryItemShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhookDeliveryItemShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhookDeliveryItemRedeliverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceStandardErrorRespModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r WebhookDeliveryItemRedeliverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhookDeliveryItemRedeliverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PipelineListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0PipelineListResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r PipelineListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PipelineListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PipelineShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0PipelineShowResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r PipelineShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PipelineShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PipelineAbortResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r PipelineAbortResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PipelineAbortResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PipelineRebuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON412      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r PipelineRebuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PipelineRebuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProvisioningProfileListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0ProvisionProfileListResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r ProvisioningProfileListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProvisioningProfileListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProvisioningProfileCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *V0ProvisionProfileResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r ProvisioningProfileCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProvisioningProfileCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProvisioningProfileDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0ProvisionProfileResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r ProvisioningProfileDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProvisioningProfileDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProvisioningProfileShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0ProvisionProfileResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r ProvisioningProfileShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProvisioningProfileShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProvisioningProfileUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0ProvisionProfileResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r ProvisioningProfileUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProvisioningProfileUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProvisioningProfileConfirmResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0ProvisionProfileResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r ProvisioningProfileConfirmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProvisioningProfileConfirmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SshKeyCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0SSHKeyRespModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r SshKeyCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SshKeyCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppWebhookCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0WebhookRespModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r AppWebhookCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppWebhookCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReleaseCreateAppStoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *V0ReleaseCreateAppStoreRespModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON403      *ServiceStandardErrorRespModel
	JSON422      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r ReleaseCreateAppStoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReleaseCreateAppStoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReleaseCreateGooglePlayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *V0ReleaseCreateGooglePlayRespModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON403      *ServiceStandardErrorRespModel
	JSON422      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r ReleaseCreateGooglePlayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReleaseCreateGooglePlayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppRolesQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppRolesQuery200Response
	JSON404      *ServiceProxyErrorRespModel
}

// Status returns HTTPResponse.Status
func (r AppRolesQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppRolesQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppRolesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppRolesQuery200Response
	JSON422      *ServiceProxyErrorRespModel
}

// Status returns HTTPResponse.Status
func (r AppRolesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppRolesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SecretListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0AppSecretListResponse
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r SecretListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SecretListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SecretDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r SecretDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SecretDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SecretUpsertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r SecretUpsertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SecretUpsertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SecretValueGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0AppSecretGetValueResponse
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r SecretValueGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SecretValueGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestDeviceListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0TestDeviceListResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r TestDeviceListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestDeviceListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppNotificationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0AppNotificationSettingsUpdateResponse
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r AppNotificationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppNotificationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildListAllResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0BuildListAllResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r BuildListAllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildListAllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0UserProfileRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r UserProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivityListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0ActivityEventListResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r ActivityListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivityListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserPlanResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0UserPlanRespModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r UserPlanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserPlanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0OrganizationListRespModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r OrgListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0OrganizationRespModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r OrgShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppListByOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0AppListResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r AppListByOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppListByOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganizationMachineTypeUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0OrganizationUpdateMachineTypeResponse
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r OrganizationMachineTypeUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganizationMachineTypeUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganzationGroupsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OrganzationGroupsList200ResponseInner
	JSON404      *ServiceProxyErrorRespModel
}

// Status returns HTTPResponse.Status
func (r OrganzationGroupsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganzationGroupsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddonListByOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0OwnerAddOnsListResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r AddonListByOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddonListByOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PipelineListAllResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0PipelineListAllResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r PipelineListAllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PipelineListAllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserMachineTypeUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0OrganizationUpdateMachineTypeResponse
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r UserMachineTypeUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserMachineTypeUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0UserProfileRespModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r UserShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddonListByUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0OwnerAddOnsListResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r AddonListByUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddonListByUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppleApiCredentialListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0AppleAPICredentialsListResponse
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r AppleApiCredentialListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppleApiCredentialListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppListByUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0AppListResponseModel
	JSON400      *ServiceStandardErrorRespModel
	JSON401      *ServiceStandardErrorRespModel
	JSON404      *ServiceStandardErrorRespModel
	JSON500      *ServiceStandardErrorRespModel
}

// Status returns HTTPResponse.Status
func (r AppListByUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppListByUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AddonsListWithResponse request returning *AddonsListResponse
func (c *ClientWithResponses) AddonsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AddonsListResponse, error) {
	rsp, err := c.AddonsList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddonsListResponse(rsp)
}

// AddonsShowWithResponse request returning *AddonsShowResponse
func (c *ClientWithResponses) AddonsShowWithResponse(ctx context.Context, addonId string, reqEditors ...RequestEditorFn) (*AddonsShowResponse, error) {
	rsp, err := c.AddonsShow(ctx, addonId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddonsShowResponse(rsp)
}

// AppListWithResponse request returning *AppListResponse
func (c *ClientWithResponses) AppListWithResponse(ctx context.Context, params *AppListParams, reqEditors ...RequestEditorFn) (*AppListResponse, error) {
	rsp, err := c.AppList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppListResponse(rsp)
}

// AppCreateWithBodyWithResponse request with arbitrary body returning *AppCreateResponse
func (c *ClientWithResponses) AppCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppCreateResponse, error) {
	rsp, err := c.AppCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppCreateResponse(rsp)
}

func (c *ClientWithResponses) AppCreateWithResponse(ctx context.Context, body AppCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AppCreateResponse, error) {
	rsp, err := c.AppCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppCreateResponse(rsp)
}

// AppDeleteWithResponse request returning *AppDeleteResponse
func (c *ClientWithResponses) AppDeleteWithResponse(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*AppDeleteResponse, error) {
	rsp, err := c.AppDelete(ctx, appSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppDeleteResponse(rsp)
}

// AppShowWithResponse request returning *AppShowResponse
func (c *ClientWithResponses) AppShowWithResponse(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*AppShowResponse, error) {
	rsp, err := c.AppShow(ctx, appSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppShowResponse(rsp)
}

// AppUpdateWithBodyWithResponse request with arbitrary body returning *AppUpdateResponse
func (c *ClientWithResponses) AppUpdateWithBodyWithResponse(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppUpdateResponse, error) {
	rsp, err := c.AppUpdateWithBody(ctx, appSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppUpdateResponse(rsp)
}

func (c *ClientWithResponses) AppUpdateWithResponse(ctx context.Context, appSlug string, body AppUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*AppUpdateResponse, error) {
	rsp, err := c.AppUpdate(ctx, appSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppUpdateResponse(rsp)
}

// AddonListByAppWithResponse request returning *AddonListByAppResponse
func (c *ClientWithResponses) AddonListByAppWithResponse(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*AddonListByAppResponse, error) {
	rsp, err := c.AddonListByApp(ctx, appSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddonListByAppResponse(rsp)
}

// AndroidKeystoreFileListWithResponse request returning *AndroidKeystoreFileListResponse
func (c *ClientWithResponses) AndroidKeystoreFileListWithResponse(ctx context.Context, appSlug string, params *AndroidKeystoreFileListParams, reqEditors ...RequestEditorFn) (*AndroidKeystoreFileListResponse, error) {
	rsp, err := c.AndroidKeystoreFileList(ctx, appSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAndroidKeystoreFileListResponse(rsp)
}

// AndroidKeystoreFileCreateWithBodyWithResponse request with arbitrary body returning *AndroidKeystoreFileCreateResponse
func (c *ClientWithResponses) AndroidKeystoreFileCreateWithBodyWithResponse(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AndroidKeystoreFileCreateResponse, error) {
	rsp, err := c.AndroidKeystoreFileCreateWithBody(ctx, appSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAndroidKeystoreFileCreateResponse(rsp)
}

func (c *ClientWithResponses) AndroidKeystoreFileCreateWithResponse(ctx context.Context, appSlug string, body AndroidKeystoreFileCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AndroidKeystoreFileCreateResponse, error) {
	rsp, err := c.AndroidKeystoreFileCreate(ctx, appSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAndroidKeystoreFileCreateResponse(rsp)
}

// AndroidKeystoreFileDeleteWithResponse request returning *AndroidKeystoreFileDeleteResponse
func (c *ClientWithResponses) AndroidKeystoreFileDeleteWithResponse(ctx context.Context, appSlug string, androidKeystoreFileSlug string, reqEditors ...RequestEditorFn) (*AndroidKeystoreFileDeleteResponse, error) {
	rsp, err := c.AndroidKeystoreFileDelete(ctx, appSlug, androidKeystoreFileSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAndroidKeystoreFileDeleteResponse(rsp)
}

// AndroidKeystoreFileConfirmWithResponse request returning *AndroidKeystoreFileConfirmResponse
func (c *ClientWithResponses) AndroidKeystoreFileConfirmWithResponse(ctx context.Context, appSlug string, androidKeystoreFileSlug string, reqEditors ...RequestEditorFn) (*AndroidKeystoreFileConfirmResponse, error) {
	rsp, err := c.AndroidKeystoreFileConfirm(ctx, appSlug, androidKeystoreFileSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAndroidKeystoreFileConfirmResponse(rsp)
}

// ArchivedBuildsListWithResponse request returning *ArchivedBuildsListResponse
func (c *ClientWithResponses) ArchivedBuildsListWithResponse(ctx context.Context, appSlug string, params *ArchivedBuildsListParams, reqEditors ...RequestEditorFn) (*ArchivedBuildsListResponse, error) {
	rsp, err := c.ArchivedBuildsList(ctx, appSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchivedBuildsListResponse(rsp)
}

// AppConfigDatastoreShowWithResponse request returning *AppConfigDatastoreShowResponse
func (c *ClientWithResponses) AppConfigDatastoreShowWithResponse(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*AppConfigDatastoreShowResponse, error) {
	rsp, err := c.AppConfigDatastoreShow(ctx, appSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppConfigDatastoreShowResponse(rsp)
}

// AppConfigCreateWithBodyWithResponse request with arbitrary body returning *AppConfigCreateResponse
func (c *ClientWithResponses) AppConfigCreateWithBodyWithResponse(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppConfigCreateResponse, error) {
	rsp, err := c.AppConfigCreateWithBody(ctx, appSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppConfigCreateResponse(rsp)
}

func (c *ClientWithResponses) AppConfigCreateWithResponse(ctx context.Context, appSlug string, body AppConfigCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AppConfigCreateResponse, error) {
	rsp, err := c.AppConfigCreate(ctx, appSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppConfigCreateResponse(rsp)
}

// AppSetupBitriseYmlConfigGetWithResponse request returning *AppSetupBitriseYmlConfigGetResponse
func (c *ClientWithResponses) AppSetupBitriseYmlConfigGetWithResponse(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*AppSetupBitriseYmlConfigGetResponse, error) {
	rsp, err := c.AppSetupBitriseYmlConfigGet(ctx, appSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppSetupBitriseYmlConfigGetResponse(rsp)
}

// AppSetupBitriseYmlConfigUpdateWithBodyWithResponse request with arbitrary body returning *AppSetupBitriseYmlConfigUpdateResponse
func (c *ClientWithResponses) AppSetupBitriseYmlConfigUpdateWithBodyWithResponse(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppSetupBitriseYmlConfigUpdateResponse, error) {
	rsp, err := c.AppSetupBitriseYmlConfigUpdateWithBody(ctx, appSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppSetupBitriseYmlConfigUpdateResponse(rsp)
}

func (c *ClientWithResponses) AppSetupBitriseYmlConfigUpdateWithResponse(ctx context.Context, appSlug string, body AppSetupBitriseYmlConfigUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*AppSetupBitriseYmlConfigUpdateResponse, error) {
	rsp, err := c.AppSetupBitriseYmlConfigUpdate(ctx, appSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppSetupBitriseYmlConfigUpdateResponse(rsp)
}

// BranchListWithResponse request returning *BranchListResponse
func (c *ClientWithResponses) BranchListWithResponse(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*BranchListResponse, error) {
	rsp, err := c.BranchList(ctx, appSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBranchListResponse(rsp)
}

// BuildCertificateListWithResponse request returning *BuildCertificateListResponse
func (c *ClientWithResponses) BuildCertificateListWithResponse(ctx context.Context, appSlug string, params *BuildCertificateListParams, reqEditors ...RequestEditorFn) (*BuildCertificateListResponse, error) {
	rsp, err := c.BuildCertificateList(ctx, appSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBuildCertificateListResponse(rsp)
}

// BuildCertificateCreateWithBodyWithResponse request with arbitrary body returning *BuildCertificateCreateResponse
func (c *ClientWithResponses) BuildCertificateCreateWithBodyWithResponse(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BuildCertificateCreateResponse, error) {
	rsp, err := c.BuildCertificateCreateWithBody(ctx, appSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBuildCertificateCreateResponse(rsp)
}

func (c *ClientWithResponses) BuildCertificateCreateWithResponse(ctx context.Context, appSlug string, body BuildCertificateCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*BuildCertificateCreateResponse, error) {
	rsp, err := c.BuildCertificateCreate(ctx, appSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBuildCertificateCreateResponse(rsp)
}

// BuildCertificateDeleteWithResponse request returning *BuildCertificateDeleteResponse
func (c *ClientWithResponses) BuildCertificateDeleteWithResponse(ctx context.Context, appSlug string, buildCertificateSlug string, reqEditors ...RequestEditorFn) (*BuildCertificateDeleteResponse, error) {
	rsp, err := c.BuildCertificateDelete(ctx, appSlug, buildCertificateSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBuildCertificateDeleteResponse(rsp)
}

// BuildCertificateShowWithResponse request returning *BuildCertificateShowResponse
func (c *ClientWithResponses) BuildCertificateShowWithResponse(ctx context.Context, appSlug string, buildCertificateSlug string, reqEditors ...RequestEditorFn) (*BuildCertificateShowResponse, error) {
	rsp, err := c.BuildCertificateShow(ctx, appSlug, buildCertificateSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBuildCertificateShowResponse(rsp)
}

// BuildCertificateUpdateWithBodyWithResponse request with arbitrary body returning *BuildCertificateUpdateResponse
func (c *ClientWithResponses) BuildCertificateUpdateWithBodyWithResponse(ctx context.Context, appSlug string, buildCertificateSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BuildCertificateUpdateResponse, error) {
	rsp, err := c.BuildCertificateUpdateWithBody(ctx, appSlug, buildCertificateSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBuildCertificateUpdateResponse(rsp)
}

func (c *ClientWithResponses) BuildCertificateUpdateWithResponse(ctx context.Context, appSlug string, buildCertificateSlug string, body BuildCertificateUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*BuildCertificateUpdateResponse, error) {
	rsp, err := c.BuildCertificateUpdate(ctx, appSlug, buildCertificateSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBuildCertificateUpdateResponse(rsp)
}

// BuildCertificateConfirmWithResponse request returning *BuildCertificateConfirmResponse
func (c *ClientWithResponses) BuildCertificateConfirmWithResponse(ctx context.Context, appSlug string, buildCertificateSlug string, reqEditors ...RequestEditorFn) (*BuildCertificateConfirmResponse, error) {
	rsp, err := c.BuildCertificateConfirm(ctx, appSlug, buildCertificateSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBuildCertificateConfirmResponse(rsp)
}

// BuildRequestListWithResponse request returning *BuildRequestListResponse
func (c *ClientWithResponses) BuildRequestListWithResponse(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*BuildRequestListResponse, error) {
	rsp, err := c.BuildRequestList(ctx, appSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBuildRequestListResponse(rsp)
}

// BuildRequestUpdateWithBodyWithResponse request with arbitrary body returning *BuildRequestUpdateResponse
func (c *ClientWithResponses) BuildRequestUpdateWithBodyWithResponse(ctx context.Context, appSlug string, buildRequestSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BuildRequestUpdateResponse, error) {
	rsp, err := c.BuildRequestUpdateWithBody(ctx, appSlug, buildRequestSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBuildRequestUpdateResponse(rsp)
}

func (c *ClientWithResponses) BuildRequestUpdateWithResponse(ctx context.Context, appSlug string, buildRequestSlug string, body BuildRequestUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*BuildRequestUpdateResponse, error) {
	rsp, err := c.BuildRequestUpdate(ctx, appSlug, buildRequestSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBuildRequestUpdateResponse(rsp)
}

// BuildWorkflowListWithResponse request returning *BuildWorkflowListResponse
func (c *ClientWithResponses) BuildWorkflowListWithResponse(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*BuildWorkflowListResponse, error) {
	rsp, err := c.BuildWorkflowList(ctx, appSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBuildWorkflowListResponse(rsp)
}

// BuildListWithResponse request returning *BuildListResponse
func (c *ClientWithResponses) BuildListWithResponse(ctx context.Context, appSlug string, params *BuildListParams, reqEditors ...RequestEditorFn) (*BuildListResponse, error) {
	rsp, err := c.BuildList(ctx, appSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBuildListResponse(rsp)
}

// BuildTriggerWithBodyWithResponse request with arbitrary body returning *BuildTriggerResponse
func (c *ClientWithResponses) BuildTriggerWithBodyWithResponse(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BuildTriggerResponse, error) {
	rsp, err := c.BuildTriggerWithBody(ctx, appSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBuildTriggerResponse(rsp)
}

func (c *ClientWithResponses) BuildTriggerWithResponse(ctx context.Context, appSlug string, body BuildTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*BuildTriggerResponse, error) {
	rsp, err := c.BuildTrigger(ctx, appSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBuildTriggerResponse(rsp)
}

// BuildShowWithResponse request returning *BuildShowResponse
func (c *ClientWithResponses) BuildShowWithResponse(ctx context.Context, appSlug string, buildSlug string, reqEditors ...RequestEditorFn) (*BuildShowResponse, error) {
	rsp, err := c.BuildShow(ctx, appSlug, buildSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBuildShowResponse(rsp)
}

// BuildAbortWithBodyWithResponse request with arbitrary body returning *BuildAbortResponse
func (c *ClientWithResponses) BuildAbortWithBodyWithResponse(ctx context.Context, appSlug string, buildSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BuildAbortResponse, error) {
	rsp, err := c.BuildAbortWithBody(ctx, appSlug, buildSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBuildAbortResponse(rsp)
}

func (c *ClientWithResponses) BuildAbortWithResponse(ctx context.Context, appSlug string, buildSlug string, body BuildAbortJSONRequestBody, reqEditors ...RequestEditorFn) (*BuildAbortResponse, error) {
	rsp, err := c.BuildAbort(ctx, appSlug, buildSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBuildAbortResponse(rsp)
}

// ArtifactListWithResponse request returning *ArtifactListResponse
func (c *ClientWithResponses) ArtifactListWithResponse(ctx context.Context, appSlug string, buildSlug string, params *ArtifactListParams, reqEditors ...RequestEditorFn) (*ArtifactListResponse, error) {
	rsp, err := c.ArtifactList(ctx, appSlug, buildSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactListResponse(rsp)
}

// ArtifactDeleteWithResponse request returning *ArtifactDeleteResponse
func (c *ClientWithResponses) ArtifactDeleteWithResponse(ctx context.Context, appSlug string, buildSlug string, artifactSlug string, reqEditors ...RequestEditorFn) (*ArtifactDeleteResponse, error) {
	rsp, err := c.ArtifactDelete(ctx, appSlug, buildSlug, artifactSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactDeleteResponse(rsp)
}

// ArtifactShowWithResponse request returning *ArtifactShowResponse
func (c *ClientWithResponses) ArtifactShowWithResponse(ctx context.Context, appSlug string, buildSlug string, artifactSlug string, params *ArtifactShowParams, reqEditors ...RequestEditorFn) (*ArtifactShowResponse, error) {
	rsp, err := c.ArtifactShow(ctx, appSlug, buildSlug, artifactSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactShowResponse(rsp)
}

// ArtifactUpdateWithBodyWithResponse request with arbitrary body returning *ArtifactUpdateResponse
func (c *ClientWithResponses) ArtifactUpdateWithBodyWithResponse(ctx context.Context, appSlug string, buildSlug string, artifactSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArtifactUpdateResponse, error) {
	rsp, err := c.ArtifactUpdateWithBody(ctx, appSlug, buildSlug, artifactSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactUpdateResponse(rsp)
}

func (c *ClientWithResponses) ArtifactUpdateWithResponse(ctx context.Context, appSlug string, buildSlug string, artifactSlug string, body ArtifactUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ArtifactUpdateResponse, error) {
	rsp, err := c.ArtifactUpdate(ctx, appSlug, buildSlug, artifactSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactUpdateResponse(rsp)
}

// BuildBitriseYmlShowWithResponse request returning *BuildBitriseYmlShowResponse
func (c *ClientWithResponses) BuildBitriseYmlShowWithResponse(ctx context.Context, appSlug string, buildSlug string, reqEditors ...RequestEditorFn) (*BuildBitriseYmlShowResponse, error) {
	rsp, err := c.BuildBitriseYmlShow(ctx, appSlug, buildSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBuildBitriseYmlShowResponse(rsp)
}

// BuildLogWithResponse request returning *BuildLogResponse
func (c *ClientWithResponses) BuildLogWithResponse(ctx context.Context, appSlug string, buildSlug string, reqEditors ...RequestEditorFn) (*BuildLogResponse, error) {
	rsp, err := c.BuildLog(ctx, appSlug, buildSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBuildLogResponse(rsp)
}

// CacheItemDeleteAllWithResponse request returning *CacheItemDeleteAllResponse
func (c *ClientWithResponses) CacheItemDeleteAllWithResponse(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*CacheItemDeleteAllResponse, error) {
	rsp, err := c.CacheItemDeleteAll(ctx, appSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCacheItemDeleteAllResponse(rsp)
}

// CacheListWithResponse request returning *CacheListResponse
func (c *ClientWithResponses) CacheListWithResponse(ctx context.Context, appSlug string, params *CacheListParams, reqEditors ...RequestEditorFn) (*CacheListResponse, error) {
	rsp, err := c.CacheList(ctx, appSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCacheListResponse(rsp)
}

// CacheItemDeleteWithResponse request returning *CacheItemDeleteResponse
func (c *ClientWithResponses) CacheItemDeleteWithResponse(ctx context.Context, appSlug string, cacheItemId string, reqEditors ...RequestEditorFn) (*CacheItemDeleteResponse, error) {
	rsp, err := c.CacheItemDelete(ctx, appSlug, cacheItemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCacheItemDeleteResponse(rsp)
}

// CacheItemDownloadWithResponse request returning *CacheItemDownloadResponse
func (c *ClientWithResponses) CacheItemDownloadWithResponse(ctx context.Context, appSlug string, cacheItemId string, reqEditors ...RequestEditorFn) (*CacheItemDownloadResponse, error) {
	rsp, err := c.CacheItemDownload(ctx, appSlug, cacheItemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCacheItemDownloadResponse(rsp)
}

// AppFinishWithBodyWithResponse request with arbitrary body returning *AppFinishResponse
func (c *ClientWithResponses) AppFinishWithBodyWithResponse(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppFinishResponse, error) {
	rsp, err := c.AppFinishWithBody(ctx, appSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppFinishResponse(rsp)
}

func (c *ClientWithResponses) AppFinishWithResponse(ctx context.Context, appSlug string, body AppFinishJSONRequestBody, reqEditors ...RequestEditorFn) (*AppFinishResponse, error) {
	rsp, err := c.AppFinish(ctx, appSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppFinishResponse(rsp)
}

// GenericProjectFileListWithResponse request returning *GenericProjectFileListResponse
func (c *ClientWithResponses) GenericProjectFileListWithResponse(ctx context.Context, appSlug string, params *GenericProjectFileListParams, reqEditors ...RequestEditorFn) (*GenericProjectFileListResponse, error) {
	rsp, err := c.GenericProjectFileList(ctx, appSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenericProjectFileListResponse(rsp)
}

// GenericProjectFilesCreateWithBodyWithResponse request with arbitrary body returning *GenericProjectFilesCreateResponse
func (c *ClientWithResponses) GenericProjectFilesCreateWithBodyWithResponse(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenericProjectFilesCreateResponse, error) {
	rsp, err := c.GenericProjectFilesCreateWithBody(ctx, appSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenericProjectFilesCreateResponse(rsp)
}

func (c *ClientWithResponses) GenericProjectFilesCreateWithResponse(ctx context.Context, appSlug string, body GenericProjectFilesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*GenericProjectFilesCreateResponse, error) {
	rsp, err := c.GenericProjectFilesCreate(ctx, appSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenericProjectFilesCreateResponse(rsp)
}

// GenericProjectFileDeleteWithResponse request returning *GenericProjectFileDeleteResponse
func (c *ClientWithResponses) GenericProjectFileDeleteWithResponse(ctx context.Context, appSlug string, genericProjectFileSlug string, reqEditors ...RequestEditorFn) (*GenericProjectFileDeleteResponse, error) {
	rsp, err := c.GenericProjectFileDelete(ctx, appSlug, genericProjectFileSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenericProjectFileDeleteResponse(rsp)
}

// GenericProjectFileShowWithResponse request returning *GenericProjectFileShowResponse
func (c *ClientWithResponses) GenericProjectFileShowWithResponse(ctx context.Context, appSlug string, genericProjectFileSlug string, reqEditors ...RequestEditorFn) (*GenericProjectFileShowResponse, error) {
	rsp, err := c.GenericProjectFileShow(ctx, appSlug, genericProjectFileSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenericProjectFileShowResponse(rsp)
}

// GenericProjectFileUpdateWithBodyWithResponse request with arbitrary body returning *GenericProjectFileUpdateResponse
func (c *ClientWithResponses) GenericProjectFileUpdateWithBodyWithResponse(ctx context.Context, appSlug string, genericProjectFileSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenericProjectFileUpdateResponse, error) {
	rsp, err := c.GenericProjectFileUpdateWithBody(ctx, appSlug, genericProjectFileSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenericProjectFileUpdateResponse(rsp)
}

func (c *ClientWithResponses) GenericProjectFileUpdateWithResponse(ctx context.Context, appSlug string, genericProjectFileSlug string, body GenericProjectFileUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*GenericProjectFileUpdateResponse, error) {
	rsp, err := c.GenericProjectFileUpdate(ctx, appSlug, genericProjectFileSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenericProjectFileUpdateResponse(rsp)
}

// GenericProjectFileConfirmWithResponse request returning *GenericProjectFileConfirmResponse
func (c *ClientWithResponses) GenericProjectFileConfirmWithResponse(ctx context.Context, appSlug string, genericProjectFileSlug string, reqEditors ...RequestEditorFn) (*GenericProjectFileConfirmResponse, error) {
	rsp, err := c.GenericProjectFileConfirm(ctx, appSlug, genericProjectFileSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenericProjectFileConfirmResponse(rsp)
}

// LocalBuildListWithResponse request returning *LocalBuildListResponse
func (c *ClientWithResponses) LocalBuildListWithResponse(ctx context.Context, appSlug string, params *LocalBuildListParams, reqEditors ...RequestEditorFn) (*LocalBuildListResponse, error) {
	rsp, err := c.LocalBuildList(ctx, appSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLocalBuildListResponse(rsp)
}

// OutgoingWebhookListWithResponse request returning *OutgoingWebhookListResponse
func (c *ClientWithResponses) OutgoingWebhookListWithResponse(ctx context.Context, appSlug string, params *OutgoingWebhookListParams, reqEditors ...RequestEditorFn) (*OutgoingWebhookListResponse, error) {
	rsp, err := c.OutgoingWebhookList(ctx, appSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOutgoingWebhookListResponse(rsp)
}

// OutgoingWebhookCreateWithBodyWithResponse request with arbitrary body returning *OutgoingWebhookCreateResponse
func (c *ClientWithResponses) OutgoingWebhookCreateWithBodyWithResponse(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OutgoingWebhookCreateResponse, error) {
	rsp, err := c.OutgoingWebhookCreateWithBody(ctx, appSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOutgoingWebhookCreateResponse(rsp)
}

// OutgoingWebhookDeleteWithResponse request returning *OutgoingWebhookDeleteResponse
func (c *ClientWithResponses) OutgoingWebhookDeleteWithResponse(ctx context.Context, appSlug string, appWebhookSlug string, reqEditors ...RequestEditorFn) (*OutgoingWebhookDeleteResponse, error) {
	rsp, err := c.OutgoingWebhookDelete(ctx, appSlug, appWebhookSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOutgoingWebhookDeleteResponse(rsp)
}

// OutgoingWebhookUpdateWithBodyWithResponse request with arbitrary body returning *OutgoingWebhookUpdateResponse
func (c *ClientWithResponses) OutgoingWebhookUpdateWithBodyWithResponse(ctx context.Context, appSlug string, appWebhookSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OutgoingWebhookUpdateResponse, error) {
	rsp, err := c.OutgoingWebhookUpdateWithBody(ctx, appSlug, appWebhookSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOutgoingWebhookUpdateResponse(rsp)
}

// WebhookDeliveryItemListWithResponse request returning *WebhookDeliveryItemListResponse
func (c *ClientWithResponses) WebhookDeliveryItemListWithResponse(ctx context.Context, appSlug string, appWebhookSlug string, params *WebhookDeliveryItemListParams, reqEditors ...RequestEditorFn) (*WebhookDeliveryItemListResponse, error) {
	rsp, err := c.WebhookDeliveryItemList(ctx, appSlug, appWebhookSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhookDeliveryItemListResponse(rsp)
}

// WebhookDeliveryItemShowWithResponse request returning *WebhookDeliveryItemShowResponse
func (c *ClientWithResponses) WebhookDeliveryItemShowWithResponse(ctx context.Context, appSlug string, appWebhookSlug string, webhookDeliveryItemSlug string, reqEditors ...RequestEditorFn) (*WebhookDeliveryItemShowResponse, error) {
	rsp, err := c.WebhookDeliveryItemShow(ctx, appSlug, appWebhookSlug, webhookDeliveryItemSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhookDeliveryItemShowResponse(rsp)
}

// WebhookDeliveryItemRedeliverWithResponse request returning *WebhookDeliveryItemRedeliverResponse
func (c *ClientWithResponses) WebhookDeliveryItemRedeliverWithResponse(ctx context.Context, appSlug string, appWebhookSlug string, webhookDeliveryItemSlug string, reqEditors ...RequestEditorFn) (*WebhookDeliveryItemRedeliverResponse, error) {
	rsp, err := c.WebhookDeliveryItemRedeliver(ctx, appSlug, appWebhookSlug, webhookDeliveryItemSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhookDeliveryItemRedeliverResponse(rsp)
}

// PipelineListWithResponse request returning *PipelineListResponse
func (c *ClientWithResponses) PipelineListWithResponse(ctx context.Context, appSlug string, params *PipelineListParams, reqEditors ...RequestEditorFn) (*PipelineListResponse, error) {
	rsp, err := c.PipelineList(ctx, appSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePipelineListResponse(rsp)
}

// PipelineShowWithResponse request returning *PipelineShowResponse
func (c *ClientWithResponses) PipelineShowWithResponse(ctx context.Context, appSlug string, pipelineId string, reqEditors ...RequestEditorFn) (*PipelineShowResponse, error) {
	rsp, err := c.PipelineShow(ctx, appSlug, pipelineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePipelineShowResponse(rsp)
}

// PipelineAbortWithBodyWithResponse request with arbitrary body returning *PipelineAbortResponse
func (c *ClientWithResponses) PipelineAbortWithBodyWithResponse(ctx context.Context, appSlug string, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PipelineAbortResponse, error) {
	rsp, err := c.PipelineAbortWithBody(ctx, appSlug, pipelineId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePipelineAbortResponse(rsp)
}

// PipelineRebuildWithBodyWithResponse request with arbitrary body returning *PipelineRebuildResponse
func (c *ClientWithResponses) PipelineRebuildWithBodyWithResponse(ctx context.Context, appSlug string, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PipelineRebuildResponse, error) {
	rsp, err := c.PipelineRebuildWithBody(ctx, appSlug, pipelineId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePipelineRebuildResponse(rsp)
}

// ProvisioningProfileListWithResponse request returning *ProvisioningProfileListResponse
func (c *ClientWithResponses) ProvisioningProfileListWithResponse(ctx context.Context, appSlug string, params *ProvisioningProfileListParams, reqEditors ...RequestEditorFn) (*ProvisioningProfileListResponse, error) {
	rsp, err := c.ProvisioningProfileList(ctx, appSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProvisioningProfileListResponse(rsp)
}

// ProvisioningProfileCreateWithBodyWithResponse request with arbitrary body returning *ProvisioningProfileCreateResponse
func (c *ClientWithResponses) ProvisioningProfileCreateWithBodyWithResponse(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProvisioningProfileCreateResponse, error) {
	rsp, err := c.ProvisioningProfileCreateWithBody(ctx, appSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProvisioningProfileCreateResponse(rsp)
}

func (c *ClientWithResponses) ProvisioningProfileCreateWithResponse(ctx context.Context, appSlug string, body ProvisioningProfileCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProvisioningProfileCreateResponse, error) {
	rsp, err := c.ProvisioningProfileCreate(ctx, appSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProvisioningProfileCreateResponse(rsp)
}

// ProvisioningProfileDeleteWithResponse request returning *ProvisioningProfileDeleteResponse
func (c *ClientWithResponses) ProvisioningProfileDeleteWithResponse(ctx context.Context, appSlug string, provisioningProfileSlug string, reqEditors ...RequestEditorFn) (*ProvisioningProfileDeleteResponse, error) {
	rsp, err := c.ProvisioningProfileDelete(ctx, appSlug, provisioningProfileSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProvisioningProfileDeleteResponse(rsp)
}

// ProvisioningProfileShowWithResponse request returning *ProvisioningProfileShowResponse
func (c *ClientWithResponses) ProvisioningProfileShowWithResponse(ctx context.Context, appSlug string, provisioningProfileSlug string, reqEditors ...RequestEditorFn) (*ProvisioningProfileShowResponse, error) {
	rsp, err := c.ProvisioningProfileShow(ctx, appSlug, provisioningProfileSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProvisioningProfileShowResponse(rsp)
}

// ProvisioningProfileUpdateWithBodyWithResponse request with arbitrary body returning *ProvisioningProfileUpdateResponse
func (c *ClientWithResponses) ProvisioningProfileUpdateWithBodyWithResponse(ctx context.Context, appSlug string, provisioningProfileSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProvisioningProfileUpdateResponse, error) {
	rsp, err := c.ProvisioningProfileUpdateWithBody(ctx, appSlug, provisioningProfileSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProvisioningProfileUpdateResponse(rsp)
}

func (c *ClientWithResponses) ProvisioningProfileUpdateWithResponse(ctx context.Context, appSlug string, provisioningProfileSlug string, body ProvisioningProfileUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProvisioningProfileUpdateResponse, error) {
	rsp, err := c.ProvisioningProfileUpdate(ctx, appSlug, provisioningProfileSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProvisioningProfileUpdateResponse(rsp)
}

// ProvisioningProfileConfirmWithResponse request returning *ProvisioningProfileConfirmResponse
func (c *ClientWithResponses) ProvisioningProfileConfirmWithResponse(ctx context.Context, appSlug string, provisioningProfileSlug string, reqEditors ...RequestEditorFn) (*ProvisioningProfileConfirmResponse, error) {
	rsp, err := c.ProvisioningProfileConfirm(ctx, appSlug, provisioningProfileSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProvisioningProfileConfirmResponse(rsp)
}

// SshKeyCreateWithBodyWithResponse request with arbitrary body returning *SshKeyCreateResponse
func (c *ClientWithResponses) SshKeyCreateWithBodyWithResponse(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SshKeyCreateResponse, error) {
	rsp, err := c.SshKeyCreateWithBody(ctx, appSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSshKeyCreateResponse(rsp)
}

func (c *ClientWithResponses) SshKeyCreateWithResponse(ctx context.Context, appSlug string, body SshKeyCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SshKeyCreateResponse, error) {
	rsp, err := c.SshKeyCreate(ctx, appSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSshKeyCreateResponse(rsp)
}

// AppWebhookCreateWithResponse request returning *AppWebhookCreateResponse
func (c *ClientWithResponses) AppWebhookCreateWithResponse(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*AppWebhookCreateResponse, error) {
	rsp, err := c.AppWebhookCreate(ctx, appSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppWebhookCreateResponse(rsp)
}

// ReleaseCreateAppStoreWithBodyWithResponse request with arbitrary body returning *ReleaseCreateAppStoreResponse
func (c *ClientWithResponses) ReleaseCreateAppStoreWithBodyWithResponse(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReleaseCreateAppStoreResponse, error) {
	rsp, err := c.ReleaseCreateAppStoreWithBody(ctx, appSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReleaseCreateAppStoreResponse(rsp)
}

func (c *ClientWithResponses) ReleaseCreateAppStoreWithResponse(ctx context.Context, appSlug string, body ReleaseCreateAppStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*ReleaseCreateAppStoreResponse, error) {
	rsp, err := c.ReleaseCreateAppStore(ctx, appSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReleaseCreateAppStoreResponse(rsp)
}

// ReleaseCreateGooglePlayWithBodyWithResponse request with arbitrary body returning *ReleaseCreateGooglePlayResponse
func (c *ClientWithResponses) ReleaseCreateGooglePlayWithBodyWithResponse(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReleaseCreateGooglePlayResponse, error) {
	rsp, err := c.ReleaseCreateGooglePlayWithBody(ctx, appSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReleaseCreateGooglePlayResponse(rsp)
}

func (c *ClientWithResponses) ReleaseCreateGooglePlayWithResponse(ctx context.Context, appSlug string, body ReleaseCreateGooglePlayJSONRequestBody, reqEditors ...RequestEditorFn) (*ReleaseCreateGooglePlayResponse, error) {
	rsp, err := c.ReleaseCreateGooglePlay(ctx, appSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReleaseCreateGooglePlayResponse(rsp)
}

// AppRolesQueryWithResponse request returning *AppRolesQueryResponse
func (c *ClientWithResponses) AppRolesQueryWithResponse(ctx context.Context, appSlug string, roleName AppRolesQueryParamsRoleName, reqEditors ...RequestEditorFn) (*AppRolesQueryResponse, error) {
	rsp, err := c.AppRolesQuery(ctx, appSlug, roleName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppRolesQueryResponse(rsp)
}

// AppRolesUpdateWithBodyWithResponse request with arbitrary body returning *AppRolesUpdateResponse
func (c *ClientWithResponses) AppRolesUpdateWithBodyWithResponse(ctx context.Context, appSlug string, roleName AppRolesUpdateParamsRoleName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppRolesUpdateResponse, error) {
	rsp, err := c.AppRolesUpdateWithBody(ctx, appSlug, roleName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppRolesUpdateResponse(rsp)
}

// SecretListWithResponse request returning *SecretListResponse
func (c *ClientWithResponses) SecretListWithResponse(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*SecretListResponse, error) {
	rsp, err := c.SecretList(ctx, appSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSecretListResponse(rsp)
}

// SecretDeleteWithResponse request returning *SecretDeleteResponse
func (c *ClientWithResponses) SecretDeleteWithResponse(ctx context.Context, appSlug string, secretName string, reqEditors ...RequestEditorFn) (*SecretDeleteResponse, error) {
	rsp, err := c.SecretDelete(ctx, appSlug, secretName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSecretDeleteResponse(rsp)
}

// SecretUpsertWithBodyWithResponse request with arbitrary body returning *SecretUpsertResponse
func (c *ClientWithResponses) SecretUpsertWithBodyWithResponse(ctx context.Context, appSlug string, secretName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SecretUpsertResponse, error) {
	rsp, err := c.SecretUpsertWithBody(ctx, appSlug, secretName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSecretUpsertResponse(rsp)
}

func (c *ClientWithResponses) SecretUpsertWithResponse(ctx context.Context, appSlug string, secretName string, body SecretUpsertJSONRequestBody, reqEditors ...RequestEditorFn) (*SecretUpsertResponse, error) {
	rsp, err := c.SecretUpsert(ctx, appSlug, secretName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSecretUpsertResponse(rsp)
}

// SecretValueGetWithResponse request returning *SecretValueGetResponse
func (c *ClientWithResponses) SecretValueGetWithResponse(ctx context.Context, appSlug string, secretName string, reqEditors ...RequestEditorFn) (*SecretValueGetResponse, error) {
	rsp, err := c.SecretValueGet(ctx, appSlug, secretName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSecretValueGetResponse(rsp)
}

// TestDeviceListWithResponse request returning *TestDeviceListResponse
func (c *ClientWithResponses) TestDeviceListWithResponse(ctx context.Context, appSlug string, reqEditors ...RequestEditorFn) (*TestDeviceListResponse, error) {
	rsp, err := c.TestDeviceList(ctx, appSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestDeviceListResponse(rsp)
}

// AppNotificationsWithBodyWithResponse request with arbitrary body returning *AppNotificationsResponse
func (c *ClientWithResponses) AppNotificationsWithBodyWithResponse(ctx context.Context, appSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppNotificationsResponse, error) {
	rsp, err := c.AppNotificationsWithBody(ctx, appSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppNotificationsResponse(rsp)
}

func (c *ClientWithResponses) AppNotificationsWithResponse(ctx context.Context, appSlug string, body AppNotificationsJSONRequestBody, reqEditors ...RequestEditorFn) (*AppNotificationsResponse, error) {
	rsp, err := c.AppNotifications(ctx, appSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppNotificationsResponse(rsp)
}

// BuildListAllWithResponse request returning *BuildListAllResponse
func (c *ClientWithResponses) BuildListAllWithResponse(ctx context.Context, params *BuildListAllParams, reqEditors ...RequestEditorFn) (*BuildListAllResponse, error) {
	rsp, err := c.BuildListAll(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBuildListAllResponse(rsp)
}

// UserProfileWithResponse request returning *UserProfileResponse
func (c *ClientWithResponses) UserProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserProfileResponse, error) {
	rsp, err := c.UserProfile(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserProfileResponse(rsp)
}

// ActivityListWithResponse request returning *ActivityListResponse
func (c *ClientWithResponses) ActivityListWithResponse(ctx context.Context, params *ActivityListParams, reqEditors ...RequestEditorFn) (*ActivityListResponse, error) {
	rsp, err := c.ActivityList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivityListResponse(rsp)
}

// UserPlanWithResponse request returning *UserPlanResponse
func (c *ClientWithResponses) UserPlanWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserPlanResponse, error) {
	rsp, err := c.UserPlan(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserPlanResponse(rsp)
}

// OrgListWithResponse request returning *OrgListResponse
func (c *ClientWithResponses) OrgListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OrgListResponse, error) {
	rsp, err := c.OrgList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgListResponse(rsp)
}

// OrgShowWithResponse request returning *OrgShowResponse
func (c *ClientWithResponses) OrgShowWithResponse(ctx context.Context, orgSlug string, reqEditors ...RequestEditorFn) (*OrgShowResponse, error) {
	rsp, err := c.OrgShow(ctx, orgSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgShowResponse(rsp)
}

// AppListByOrganizationWithResponse request returning *AppListByOrganizationResponse
func (c *ClientWithResponses) AppListByOrganizationWithResponse(ctx context.Context, orgSlug string, params *AppListByOrganizationParams, reqEditors ...RequestEditorFn) (*AppListByOrganizationResponse, error) {
	rsp, err := c.AppListByOrganization(ctx, orgSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppListByOrganizationResponse(rsp)
}

// OrganizationMachineTypeUpdateWithBodyWithResponse request with arbitrary body returning *OrganizationMachineTypeUpdateResponse
func (c *ClientWithResponses) OrganizationMachineTypeUpdateWithBodyWithResponse(ctx context.Context, orgSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrganizationMachineTypeUpdateResponse, error) {
	rsp, err := c.OrganizationMachineTypeUpdateWithBody(ctx, orgSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationMachineTypeUpdateResponse(rsp)
}

func (c *ClientWithResponses) OrganizationMachineTypeUpdateWithResponse(ctx context.Context, orgSlug string, body OrganizationMachineTypeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*OrganizationMachineTypeUpdateResponse, error) {
	rsp, err := c.OrganizationMachineTypeUpdate(ctx, orgSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationMachineTypeUpdateResponse(rsp)
}

// OrganzationGroupsListWithResponse request returning *OrganzationGroupsListResponse
func (c *ClientWithResponses) OrganzationGroupsListWithResponse(ctx context.Context, orgSlug string, reqEditors ...RequestEditorFn) (*OrganzationGroupsListResponse, error) {
	rsp, err := c.OrganzationGroupsList(ctx, orgSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganzationGroupsListResponse(rsp)
}

// AddonListByOrganizationWithResponse request returning *AddonListByOrganizationResponse
func (c *ClientWithResponses) AddonListByOrganizationWithResponse(ctx context.Context, organizationSlug string, reqEditors ...RequestEditorFn) (*AddonListByOrganizationResponse, error) {
	rsp, err := c.AddonListByOrganization(ctx, organizationSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddonListByOrganizationResponse(rsp)
}

// PipelineListAllWithResponse request returning *PipelineListAllResponse
func (c *ClientWithResponses) PipelineListAllWithResponse(ctx context.Context, params *PipelineListAllParams, reqEditors ...RequestEditorFn) (*PipelineListAllResponse, error) {
	rsp, err := c.PipelineListAll(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePipelineListAllResponse(rsp)
}

// UserMachineTypeUpdateWithBodyWithResponse request with arbitrary body returning *UserMachineTypeUpdateResponse
func (c *ClientWithResponses) UserMachineTypeUpdateWithBodyWithResponse(ctx context.Context, userSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserMachineTypeUpdateResponse, error) {
	rsp, err := c.UserMachineTypeUpdateWithBody(ctx, userSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserMachineTypeUpdateResponse(rsp)
}

func (c *ClientWithResponses) UserMachineTypeUpdateWithResponse(ctx context.Context, userSlug string, body UserMachineTypeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserMachineTypeUpdateResponse, error) {
	rsp, err := c.UserMachineTypeUpdate(ctx, userSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserMachineTypeUpdateResponse(rsp)
}

// UserShowWithResponse request returning *UserShowResponse
func (c *ClientWithResponses) UserShowWithResponse(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*UserShowResponse, error) {
	rsp, err := c.UserShow(ctx, userSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserShowResponse(rsp)
}

// AddonListByUserWithResponse request returning *AddonListByUserResponse
func (c *ClientWithResponses) AddonListByUserWithResponse(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*AddonListByUserResponse, error) {
	rsp, err := c.AddonListByUser(ctx, userSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddonListByUserResponse(rsp)
}

// AppleApiCredentialListWithResponse request returning *AppleApiCredentialListResponse
func (c *ClientWithResponses) AppleApiCredentialListWithResponse(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*AppleApiCredentialListResponse, error) {
	rsp, err := c.AppleApiCredentialList(ctx, userSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppleApiCredentialListResponse(rsp)
}

// AppListByUserWithResponse request returning *AppListByUserResponse
func (c *ClientWithResponses) AppListByUserWithResponse(ctx context.Context, userSlug string, params *AppListByUserParams, reqEditors ...RequestEditorFn) (*AppListByUserResponse, error) {
	rsp, err := c.AppListByUser(ctx, userSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppListByUserResponse(rsp)
}

// ParseAddonsListResponse parses an HTTP response from a AddonsListWithResponse call
func ParseAddonsListResponse(rsp *http.Response) (*AddonsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddonsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0AddonsListResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddonsShowResponse parses an HTTP response from a AddonsShowWithResponse call
func ParseAddonsShowResponse(rsp *http.Response) (*AddonsShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddonsShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0AddonsShowResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAppListResponse parses an HTTP response from a AppListWithResponse call
func ParseAppListResponse(rsp *http.Response) (*AppListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0AppListResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAppCreateResponse parses an HTTP response from a AppCreateWithResponse call
func ParseAppCreateResponse(rsp *http.Response) (*AppCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0AppRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceProxyErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceProxyErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceProxyErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceProxyErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAppDeleteResponse parses an HTTP response from a AppDeleteWithResponse call
func ParseAppDeleteResponse(rsp *http.Response) (*AppDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0AppDeleteRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAppShowResponse parses an HTTP response from a AppShowWithResponse call
func ParseAppShowResponse(rsp *http.Response) (*AppShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0AppShowResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAppUpdateResponse parses an HTTP response from a AppUpdateWithResponse call
func ParseAppUpdateResponse(rsp *http.Response) (*AppUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0AppUpdateRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddonListByAppResponse parses an HTTP response from a AddonListByAppWithResponse call
func ParseAddonListByAppResponse(rsp *http.Response) (*AddonListByAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddonListByAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0AppAddOnsListResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAndroidKeystoreFileListResponse parses an HTTP response from a AndroidKeystoreFileListWithResponse call
func ParseAndroidKeystoreFileListResponse(rsp *http.Response) (*AndroidKeystoreFileListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AndroidKeystoreFileListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0ProjectFileStorageListResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAndroidKeystoreFileCreateResponse parses an HTTP response from a AndroidKeystoreFileCreateWithResponse call
func ParseAndroidKeystoreFileCreateResponse(rsp *http.Response) (*AndroidKeystoreFileCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AndroidKeystoreFileCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest V0ProjectFileStorageResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAndroidKeystoreFileDeleteResponse parses an HTTP response from a AndroidKeystoreFileDeleteWithResponse call
func ParseAndroidKeystoreFileDeleteResponse(rsp *http.Response) (*AndroidKeystoreFileDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AndroidKeystoreFileDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0ProjectFileStorageResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAndroidKeystoreFileConfirmResponse parses an HTTP response from a AndroidKeystoreFileConfirmWithResponse call
func ParseAndroidKeystoreFileConfirmResponse(rsp *http.Response) (*AndroidKeystoreFileConfirmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AndroidKeystoreFileConfirmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0ProjectFileStorageResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseArchivedBuildsListResponse parses an HTTP response from a ArchivedBuildsListWithResponse call
func ParseArchivedBuildsListResponse(rsp *http.Response) (*ArchivedBuildsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchivedBuildsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0ArchivedBuildListResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAppConfigDatastoreShowResponse parses an HTTP response from a AppConfigDatastoreShowWithResponse call
func ParseAppConfigDatastoreShowResponse(rsp *http.Response) (*AppConfigDatastoreShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppConfigDatastoreShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAppConfigCreateResponse parses an HTTP response from a AppConfigCreateWithResponse call
func ParseAppConfigCreateResponse(rsp *http.Response) (*AppConfigCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppConfigCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0AppConfigRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceProxyErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAppSetupBitriseYmlConfigGetResponse parses an HTTP response from a AppSetupBitriseYmlConfigGetWithResponse call
func ParseAppSetupBitriseYmlConfigGetResponse(rsp *http.Response) (*AppSetupBitriseYmlConfigGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppSetupBitriseYmlConfigGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0BitriseYMLConfigGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAppSetupBitriseYmlConfigUpdateResponse parses an HTTP response from a AppSetupBitriseYmlConfigUpdateWithResponse call
func ParseAppSetupBitriseYmlConfigUpdateResponse(rsp *http.Response) (*AppSetupBitriseYmlConfigUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppSetupBitriseYmlConfigUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseBranchListResponse parses an HTTP response from a BranchListWithResponse call
func ParseBranchListResponse(rsp *http.Response) (*BranchListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BranchListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0BranchListResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseBuildCertificateListResponse parses an HTTP response from a BuildCertificateListWithResponse call
func ParseBuildCertificateListResponse(rsp *http.Response) (*BuildCertificateListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BuildCertificateListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0BuildCertificateListResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseBuildCertificateCreateResponse parses an HTTP response from a BuildCertificateCreateWithResponse call
func ParseBuildCertificateCreateResponse(rsp *http.Response) (*BuildCertificateCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BuildCertificateCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest V0BuildCertificateResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseBuildCertificateDeleteResponse parses an HTTP response from a BuildCertificateDeleteWithResponse call
func ParseBuildCertificateDeleteResponse(rsp *http.Response) (*BuildCertificateDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BuildCertificateDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0BuildCertificateResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseBuildCertificateShowResponse parses an HTTP response from a BuildCertificateShowWithResponse call
func ParseBuildCertificateShowResponse(rsp *http.Response) (*BuildCertificateShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BuildCertificateShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0BuildCertificateResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseBuildCertificateUpdateResponse parses an HTTP response from a BuildCertificateUpdateWithResponse call
func ParseBuildCertificateUpdateResponse(rsp *http.Response) (*BuildCertificateUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BuildCertificateUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0BuildCertificateResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseBuildCertificateConfirmResponse parses an HTTP response from a BuildCertificateConfirmWithResponse call
func ParseBuildCertificateConfirmResponse(rsp *http.Response) (*BuildCertificateConfirmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BuildCertificateConfirmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0BuildCertificateResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseBuildRequestListResponse parses an HTTP response from a BuildRequestListWithResponse call
func ParseBuildRequestListResponse(rsp *http.Response) (*BuildRequestListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BuildRequestListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0BuildRequestListResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseBuildRequestUpdateResponse parses an HTTP response from a BuildRequestUpdateWithResponse call
func ParseBuildRequestUpdateResponse(rsp *http.Response) (*BuildRequestUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BuildRequestUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0BuildRequestUpdateResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseBuildWorkflowListResponse parses an HTTP response from a BuildWorkflowListWithResponse call
func ParseBuildWorkflowListResponse(rsp *http.Response) (*BuildWorkflowListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BuildWorkflowListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0BuildWorkflowListResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseBuildListResponse parses an HTTP response from a BuildListWithResponse call
func ParseBuildListResponse(rsp *http.Response) (*BuildListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BuildListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0BuildListResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseBuildTriggerResponse parses an HTTP response from a BuildTriggerWithResponse call
func ParseBuildTriggerResponse(rsp *http.Response) (*BuildTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BuildTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest V0BuildTriggerRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseBuildShowResponse parses an HTTP response from a BuildShowWithResponse call
func ParseBuildShowResponse(rsp *http.Response) (*BuildShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BuildShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0BuildShowResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseBuildAbortResponse parses an HTTP response from a BuildAbortWithResponse call
func ParseBuildAbortResponse(rsp *http.Response) (*BuildAbortResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BuildAbortResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0BuildAbortResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseArtifactListResponse parses an HTTP response from a ArtifactListWithResponse call
func ParseArtifactListResponse(rsp *http.Response) (*ArtifactListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArtifactListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0ArtifactListResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseArtifactDeleteResponse parses an HTTP response from a ArtifactDeleteWithResponse call
func ParseArtifactDeleteResponse(rsp *http.Response) (*ArtifactDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArtifactDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0ArtifactDeleteResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseArtifactShowResponse parses an HTTP response from a ArtifactShowWithResponse call
func ParseArtifactShowResponse(rsp *http.Response) (*ArtifactShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArtifactShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0ArtifactShowResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseArtifactUpdateResponse parses an HTTP response from a ArtifactUpdateWithResponse call
func ParseArtifactUpdateResponse(rsp *http.Response) (*ArtifactUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArtifactUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0ArtifactShowResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseBuildBitriseYmlShowResponse parses an HTTP response from a BuildBitriseYmlShowWithResponse call
func ParseBuildBitriseYmlShowResponse(rsp *http.Response) (*BuildBitriseYmlShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BuildBitriseYmlShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseBuildLogResponse parses an HTTP response from a BuildLogWithResponse call
func ParseBuildLogResponse(rsp *http.Response) (*BuildLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BuildLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCacheItemDeleteAllResponse parses an HTTP response from a CacheItemDeleteAllWithResponse call
func ParseCacheItemDeleteAllResponse(rsp *http.Response) (*CacheItemDeleteAllResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CacheItemDeleteAllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCacheListResponse parses an HTTP response from a CacheListWithResponse call
func ParseCacheListResponse(rsp *http.Response) (*CacheListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CacheListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0CacheItemListResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCacheItemDeleteResponse parses an HTTP response from a CacheItemDeleteWithResponse call
func ParseCacheItemDeleteResponse(rsp *http.Response) (*CacheItemDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CacheItemDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCacheItemDownloadResponse parses an HTTP response from a CacheItemDownloadWithResponse call
func ParseCacheItemDownloadResponse(rsp *http.Response) (*CacheItemDownloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CacheItemDownloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0CacheItemDownloadResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAppFinishResponse parses an HTTP response from a AppFinishWithResponse call
func ParseAppFinishResponse(rsp *http.Response) (*AppFinishResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppFinishResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0AppFinishRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGenericProjectFileListResponse parses an HTTP response from a GenericProjectFileListWithResponse call
func ParseGenericProjectFileListResponse(rsp *http.Response) (*GenericProjectFileListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenericProjectFileListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0ProjectFileStorageListResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGenericProjectFilesCreateResponse parses an HTTP response from a GenericProjectFilesCreateWithResponse call
func ParseGenericProjectFilesCreateResponse(rsp *http.Response) (*GenericProjectFilesCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenericProjectFilesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest V0ProjectFileStorageResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGenericProjectFileDeleteResponse parses an HTTP response from a GenericProjectFileDeleteWithResponse call
func ParseGenericProjectFileDeleteResponse(rsp *http.Response) (*GenericProjectFileDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenericProjectFileDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0ProjectFileStorageResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGenericProjectFileShowResponse parses an HTTP response from a GenericProjectFileShowWithResponse call
func ParseGenericProjectFileShowResponse(rsp *http.Response) (*GenericProjectFileShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenericProjectFileShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0ProjectFileStorageResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGenericProjectFileUpdateResponse parses an HTTP response from a GenericProjectFileUpdateWithResponse call
func ParseGenericProjectFileUpdateResponse(rsp *http.Response) (*GenericProjectFileUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenericProjectFileUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0ProjectFileStorageResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGenericProjectFileConfirmResponse parses an HTTP response from a GenericProjectFileConfirmWithResponse call
func ParseGenericProjectFileConfirmResponse(rsp *http.Response) (*GenericProjectFileConfirmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenericProjectFileConfirmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0ProjectFileStorageResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseLocalBuildListResponse parses an HTTP response from a LocalBuildListWithResponse call
func ParseLocalBuildListResponse(rsp *http.Response) (*LocalBuildListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LocalBuildListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0PipelineListResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOutgoingWebhookListResponse parses an HTTP response from a OutgoingWebhookListWithResponse call
func ParseOutgoingWebhookListResponse(rsp *http.Response) (*OutgoingWebhookListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OutgoingWebhookListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0AppWebhookListResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOutgoingWebhookCreateResponse parses an HTTP response from a OutgoingWebhookCreateWithResponse call
func ParseOutgoingWebhookCreateResponse(rsp *http.Response) (*OutgoingWebhookCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OutgoingWebhookCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0AppWebhookCreatedResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOutgoingWebhookDeleteResponse parses an HTTP response from a OutgoingWebhookDeleteWithResponse call
func ParseOutgoingWebhookDeleteResponse(rsp *http.Response) (*OutgoingWebhookDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OutgoingWebhookDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0AppWebhookDeletedResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOutgoingWebhookUpdateResponse parses an HTTP response from a OutgoingWebhookUpdateWithResponse call
func ParseOutgoingWebhookUpdateResponse(rsp *http.Response) (*OutgoingWebhookUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OutgoingWebhookUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0AppWebhookResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWebhookDeliveryItemListResponse parses an HTTP response from a WebhookDeliveryItemListWithResponse call
func ParseWebhookDeliveryItemListResponse(rsp *http.Response) (*WebhookDeliveryItemListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhookDeliveryItemListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0WebhookDeliveryItemShowResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWebhookDeliveryItemShowResponse parses an HTTP response from a WebhookDeliveryItemShowWithResponse call
func ParseWebhookDeliveryItemShowResponse(rsp *http.Response) (*WebhookDeliveryItemShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhookDeliveryItemShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0WebhookDeliveryItemResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWebhookDeliveryItemRedeliverResponse parses an HTTP response from a WebhookDeliveryItemRedeliverWithResponse call
func ParseWebhookDeliveryItemRedeliverResponse(rsp *http.Response) (*WebhookDeliveryItemRedeliverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhookDeliveryItemRedeliverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePipelineListResponse parses an HTTP response from a PipelineListWithResponse call
func ParsePipelineListResponse(rsp *http.Response) (*PipelineListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PipelineListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0PipelineListResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePipelineShowResponse parses an HTTP response from a PipelineShowWithResponse call
func ParsePipelineShowResponse(rsp *http.Response) (*PipelineShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PipelineShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0PipelineShowResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePipelineAbortResponse parses an HTTP response from a PipelineAbortWithResponse call
func ParsePipelineAbortResponse(rsp *http.Response) (*PipelineAbortResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PipelineAbortResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePipelineRebuildResponse parses an HTTP response from a PipelineRebuildWithResponse call
func ParsePipelineRebuildResponse(rsp *http.Response) (*PipelineRebuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PipelineRebuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseProvisioningProfileListResponse parses an HTTP response from a ProvisioningProfileListWithResponse call
func ParseProvisioningProfileListResponse(rsp *http.Response) (*ProvisioningProfileListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProvisioningProfileListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0ProvisionProfileListResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseProvisioningProfileCreateResponse parses an HTTP response from a ProvisioningProfileCreateWithResponse call
func ParseProvisioningProfileCreateResponse(rsp *http.Response) (*ProvisioningProfileCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProvisioningProfileCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest V0ProvisionProfileResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseProvisioningProfileDeleteResponse parses an HTTP response from a ProvisioningProfileDeleteWithResponse call
func ParseProvisioningProfileDeleteResponse(rsp *http.Response) (*ProvisioningProfileDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProvisioningProfileDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0ProvisionProfileResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseProvisioningProfileShowResponse parses an HTTP response from a ProvisioningProfileShowWithResponse call
func ParseProvisioningProfileShowResponse(rsp *http.Response) (*ProvisioningProfileShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProvisioningProfileShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0ProvisionProfileResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseProvisioningProfileUpdateResponse parses an HTTP response from a ProvisioningProfileUpdateWithResponse call
func ParseProvisioningProfileUpdateResponse(rsp *http.Response) (*ProvisioningProfileUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProvisioningProfileUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0ProvisionProfileResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseProvisioningProfileConfirmResponse parses an HTTP response from a ProvisioningProfileConfirmWithResponse call
func ParseProvisioningProfileConfirmResponse(rsp *http.Response) (*ProvisioningProfileConfirmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProvisioningProfileConfirmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0ProvisionProfileResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSshKeyCreateResponse parses an HTTP response from a SshKeyCreateWithResponse call
func ParseSshKeyCreateResponse(rsp *http.Response) (*SshKeyCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SshKeyCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0SSHKeyRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAppWebhookCreateResponse parses an HTTP response from a AppWebhookCreateWithResponse call
func ParseAppWebhookCreateResponse(rsp *http.Response) (*AppWebhookCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppWebhookCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0WebhookRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReleaseCreateAppStoreResponse parses an HTTP response from a ReleaseCreateAppStoreWithResponse call
func ParseReleaseCreateAppStoreResponse(rsp *http.Response) (*ReleaseCreateAppStoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReleaseCreateAppStoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest V0ReleaseCreateAppStoreRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReleaseCreateGooglePlayResponse parses an HTTP response from a ReleaseCreateGooglePlayWithResponse call
func ParseReleaseCreateGooglePlayResponse(rsp *http.Response) (*ReleaseCreateGooglePlayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReleaseCreateGooglePlayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest V0ReleaseCreateGooglePlayRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAppRolesQueryResponse parses an HTTP response from a AppRolesQueryWithResponse call
func ParseAppRolesQueryResponse(rsp *http.Response) (*AppRolesQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppRolesQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppRolesQuery200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceProxyErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppRolesUpdateResponse parses an HTTP response from a AppRolesUpdateWithResponse call
func ParseAppRolesUpdateResponse(rsp *http.Response) (*AppRolesUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppRolesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppRolesQuery200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ServiceProxyErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSecretListResponse parses an HTTP response from a SecretListWithResponse call
func ParseSecretListResponse(rsp *http.Response) (*SecretListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SecretListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0AppSecretListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSecretDeleteResponse parses an HTTP response from a SecretDeleteWithResponse call
func ParseSecretDeleteResponse(rsp *http.Response) (*SecretDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SecretDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSecretUpsertResponse parses an HTTP response from a SecretUpsertWithResponse call
func ParseSecretUpsertResponse(rsp *http.Response) (*SecretUpsertResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SecretUpsertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSecretValueGetResponse parses an HTTP response from a SecretValueGetWithResponse call
func ParseSecretValueGetResponse(rsp *http.Response) (*SecretValueGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SecretValueGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0AppSecretGetValueResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTestDeviceListResponse parses an HTTP response from a TestDeviceListWithResponse call
func ParseTestDeviceListResponse(rsp *http.Response) (*TestDeviceListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestDeviceListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0TestDeviceListResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAppNotificationsResponse parses an HTTP response from a AppNotificationsWithResponse call
func ParseAppNotificationsResponse(rsp *http.Response) (*AppNotificationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppNotificationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0AppNotificationSettingsUpdateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseBuildListAllResponse parses an HTTP response from a BuildListAllWithResponse call
func ParseBuildListAllResponse(rsp *http.Response) (*BuildListAllResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BuildListAllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0BuildListAllResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUserProfileResponse parses an HTTP response from a UserProfileWithResponse call
func ParseUserProfileResponse(rsp *http.Response) (*UserProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0UserProfileRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseActivityListResponse parses an HTTP response from a ActivityListWithResponse call
func ParseActivityListResponse(rsp *http.Response) (*ActivityListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivityListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0ActivityEventListResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUserPlanResponse parses an HTTP response from a UserPlanWithResponse call
func ParseUserPlanResponse(rsp *http.Response) (*UserPlanResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserPlanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0UserPlanRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrgListResponse parses an HTTP response from a OrgListWithResponse call
func ParseOrgListResponse(rsp *http.Response) (*OrgListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0OrganizationListRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrgShowResponse parses an HTTP response from a OrgShowWithResponse call
func ParseOrgShowResponse(rsp *http.Response) (*OrgShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0OrganizationRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAppListByOrganizationResponse parses an HTTP response from a AppListByOrganizationWithResponse call
func ParseAppListByOrganizationResponse(rsp *http.Response) (*AppListByOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppListByOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0AppListResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrganizationMachineTypeUpdateResponse parses an HTTP response from a OrganizationMachineTypeUpdateWithResponse call
func ParseOrganizationMachineTypeUpdateResponse(rsp *http.Response) (*OrganizationMachineTypeUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganizationMachineTypeUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0OrganizationUpdateMachineTypeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrganzationGroupsListResponse parses an HTTP response from a OrganzationGroupsListWithResponse call
func ParseOrganzationGroupsListResponse(rsp *http.Response) (*OrganzationGroupsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganzationGroupsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OrganzationGroupsList200ResponseInner
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceProxyErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAddonListByOrganizationResponse parses an HTTP response from a AddonListByOrganizationWithResponse call
func ParseAddonListByOrganizationResponse(rsp *http.Response) (*AddonListByOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddonListByOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0OwnerAddOnsListResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePipelineListAllResponse parses an HTTP response from a PipelineListAllWithResponse call
func ParsePipelineListAllResponse(rsp *http.Response) (*PipelineListAllResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PipelineListAllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0PipelineListAllResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUserMachineTypeUpdateResponse parses an HTTP response from a UserMachineTypeUpdateWithResponse call
func ParseUserMachineTypeUpdateResponse(rsp *http.Response) (*UserMachineTypeUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserMachineTypeUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0OrganizationUpdateMachineTypeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUserShowResponse parses an HTTP response from a UserShowWithResponse call
func ParseUserShowResponse(rsp *http.Response) (*UserShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0UserProfileRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddonListByUserResponse parses an HTTP response from a AddonListByUserWithResponse call
func ParseAddonListByUserResponse(rsp *http.Response) (*AddonListByUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddonListByUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0OwnerAddOnsListResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAppleApiCredentialListResponse parses an HTTP response from a AppleApiCredentialListWithResponse call
func ParseAppleApiCredentialListResponse(rsp *http.Response) (*AppleApiCredentialListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppleApiCredentialListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0AppleAPICredentialsListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAppListByUserResponse parses an HTTP response from a AppListByUserWithResponse call
func ParseAppListByUserResponse(rsp *http.Response) (*AppListByUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppListByUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0AppListResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServiceStandardErrorRespModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"X/+/AAAA///NAh8a8okDAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
